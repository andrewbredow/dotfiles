[{"url":"http:\/\/nodejs.org\/api\/all.html#all_global","title":"global","description":"In browsers, the top-level scope is the global scope. That means that in browsers if you&#39;re in the global scope var something will define a global variable. In Node this is different. The top-level scope is not the global scope; var something inside a Node module will be local to that module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process","title":"process","description":"The process object. See the [process object][] section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console","title":"console","description":"Used to print to stdout and stderr. See the [stdio][] section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_class_buffer","title":"Class: Buffer","description":"Used to handle binary data. See the [buffer section][]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_clearinterval_t","title":"clearInterval(t)","description":"Stop a timer that was previously created with setInterval(). The callback will not execute.   The timer functions are global variables. See the [timers][] section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console","title":"console","description":"For printing to stdout and stderr.  Similar to the console object functions provided by most web browsers, here the output is sent to stdout or stderr."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_log_data","title":"console.log([data], [...])","description":"Prints to stdout with newline. This function can take multiple arguments in a printf()-like way. Example:   console.log(&#39;count: %d&#39;, count); If formatting elements are not found in the first string then util.inspect is used on each argument.  See [util.format()][] for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_info_data","title":"console.info([data], [...])","description":"Same as console.log."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_error_data","title":"console.error([data], [...])","description":"Same as console.log but prints to stderr."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_warn_data","title":"console.warn([data], [...])","description":"Same as console.error."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_dir_obj","title":"console.dir(obj)","description":"Uses util.inspect on obj and prints resulting string to stdout."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_time_label","title":"console.time(label)","description":"Mark a time."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_timeend_label","title":"console.timeEnd(label)","description":"Finish timer, record output. Example:   console.time(&#39;100-elements&#39;); for (var i = 0; i < 100; i++) {   ; } console.timeEnd(&#39;100-elements&#39;);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_trace_label","title":"console.trace(label)","description":"Print a stack trace to stderr of the current position."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_assert_expression_message","title":"console.assert(expression, [message])","description":"Same as [assert.ok()][] where if the expression evaluates as false throw an AssertionError with message."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process","title":"process","description":"The process object is a global object and can be accessed from anywhere. It is an instance of [EventEmitter][]."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_abort","title":"process.abort()","description":"This causes node to emit an abort. This will cause node to exit and generate a core file."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_chdir_directory","title":"process.chdir(directory)","description":"Changes the current working directory of the process or throws an exception if that fails.   console.log(&#39;Starting directory: &#39; + process.cwd()); try {   process.chdir(&#39;\/tmp&#39;);   console.log(&#39;New directory: &#39; + process.cwd()); } catch (err) {   console.log(&#39;chdir: &#39; + err); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_cwd","title":"process.cwd()","description":"Returns the current working directory of the process.   console.log(&#39;Current directory: &#39; + process.cwd());"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_exit_code","title":"process.exit([code])","description":"Ends the process with the specified code.  If omitted, exit uses the &#39;success&#39; code 0.   To exit with a &#39;failure&#39; code:   process.exit(1); The shell that executed node should see the exit code as 1."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_getgid","title":"process.getgid()","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Gets the group identity of the process. (See getgid(2).) This is the numerical group id, not the group name.   if (process.getgid) {   console.log(&#39;Current gid: &#39; + process.getgid()); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_setgid_id","title":"process.setgid(id)","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Sets the group identity of the process. (See setgid(2).)  This accepts either a numerical ID or a groupname string. If a groupname is specified, this method blocks while resolving it to a numerical ID.   if (process.getgid && process.setgid) {   console.log(&#39;Current gid: &#39; + process.getgid());   try {     process.setgid(501);     console.log(&#39;New gid: &#39; + process.getgid());   }   catch (err) {     console.log(&#39;Failed to set gid: &#39; + err);   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_getuid","title":"process.getuid()","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Gets the user identity of the process. (See getuid(2).) This is the numerical userid, not the username.   if (process.getuid) {   console.log(&#39;Current uid: &#39; + process.getuid()); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_setuid_id","title":"process.setuid(id)","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Sets the user identity of the process. (See setuid(2).)  This accepts either a numerical ID or a username string.  If a username is specified, this method blocks while resolving it to a numerical ID.   if (process.getuid && process.setuid) {   console.log(&#39;Current uid: &#39; + process.getuid());   try {     process.setuid(501);     console.log(&#39;New uid: &#39; + process.getuid());   }   catch (err) {     console.log(&#39;Failed to set uid: &#39; + err);   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_getgroups","title":"process.getgroups()","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Returns an array with the supplementary group IDs. POSIX leaves it unspecified if the effective group ID is included but node.js ensures it always is."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_setgroups_groups","title":"process.setgroups(groups)","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Sets the supplementary group IDs. This is a privileged operation, meaning you need to be root or have the CAP_SETGID capability.   The list can contain group IDs, group names or both."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_initgroups_user_extra_group","title":"process.initgroups(user, extra_group)","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Reads \/etc\/group and initializes the group access list, using all groups of which the user is a member. This is a privileged operation, meaning you need to be root or have the CAP_SETGID capability.   user is a user name or user ID. extra_group is a group name or group ID.   Some care needs to be taken when dropping privileges. Example:   console.log(process.getgroups());         \/\/ [ 0 ] process.initgroups(&#39;bnoordhuis&#39;, 1000);   \/\/ switch user console.log(process.getgroups());         \/\/ [ 27, 30, 46, 1000, 0 ] process.setgid(1000);                     \/\/ drop root gid console.log(process.getgroups());         \/\/ [ 27, 30, 46, 1000 ]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_kill_pid_signal","title":"process.kill(pid, [signal])","description":"Send a signal to a process. pid is the process id and signal is the string describing the signal to send.  Signal names are strings like &#39;SIGINT&#39; or &#39;SIGUSR1&#39;.  If omitted, the signal will be &#39;SIGTERM&#39;. See kill(2) for more information.   Note that just because the name of this function is process.kill, it is really just a signal sender, like the kill system call.  The signal sent may do something other than kill the target process.   Example of sending a signal to yourself:   process.on(&#39;SIGHUP&#39;, function() {   console.log(&#39;Got SIGHUP signal.&#39;); });  setTimeout(function() {   console.log(&#39;Exiting.&#39;);   process.exit(0); }, 100);  process.kill(process.pid, &#39;SIGHUP&#39;);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_memoryusage","title":"process.memoryUsage()","description":"Returns an object describing the memory usage of the Node process measured in bytes.   var util = require(&#39;util&#39;);  console.log(util.inspect(process.memoryUsage())); This will generate:   { rss: 4935680,   heapTotal: 1826816,   heapUsed: 650472 } heapTotal and heapUsed refer to V8&#39;s memory usage."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_nexttick_callback","title":"process.nextTick(callback)","description":"On the next loop around the event loop call this callback. This is not a simple alias to setTimeout(fn, 0), it&#39;s much more efficient.  It typically runs before any other I\/O events fire, but there are some exceptions.  See process.maxTickDepth below.   process.nextTick(function() {   console.log(&#39;nextTick callback&#39;); }); This is important in developing APIs where you want to give the user the chance to assign event handlers after an object has been constructed, but before any I\/O has occurred.   function MyThing(options) {   this.setupOptions(options);    process.nextTick(function() {     this.startDoingStuff();   }.bind(this)); }  var thing = new MyThing(); thing.getReadyForStuff();  \/\/ thing.startDoingStuff() gets called now, not before. It is very important for APIs to be either 100% synchronous or 100% asynchronous.  Consider this example:   \/\/ WARNING!  DO NOT USE!  BAD UNSAFE HAZARD! function maybeSync(arg, cb) {   if (arg) {     cb();     return;   }    fs.stat(&#39;file&#39;, cb); } This API is hazardous.  If you do this:   maybeSync(true, function() {   foo(); }); bar(); then it&#39;s not clear whether foo() or bar() will be called first.   This approach is much better:   function definitelyAsync(arg, cb) {   if (arg) {     process.nextTick(cb);     return;   }    fs.stat(&#39;file&#39;, cb); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_umask_mask","title":"process.umask([mask])","description":"Sets or reads the process&#39;s file mode creation mask. Child processes inherit the mask from the parent process. Returns the old mask if mask argument is given, otherwise returns the current mask.   var oldmask, newmask = 0644;  oldmask = process.umask(newmask); console.log(&#39;Changed umask from: &#39; + oldmask.toString(8) +             &#39; to &#39; + newmask.toString(8));"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_uptime","title":"process.uptime()","description":"Number of seconds Node has been running."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_hrtime","title":"process.hrtime()","description":"Returns the current high-resolution real time in a [seconds, nanoseconds] tuple Array. It is relative to an arbitrary time in the past. It is not related to the time of day and therefore not subject to clock drift. The primary use is for measuring performance between intervals.   You may pass in the result of a previous call to process.hrtime() to get a diff reading, useful for benchmarks and measuring intervals:   var time = process.hrtime(); \/\/ [ 1800216, 25 ]  setTimeout(function() {   var diff = process.hrtime(time);   \/\/ [ 1, 552 ]    console.log(&#39;benchmark took %d nanoseconds&#39;, diff[0] * 1e9 + diff[1]);   \/\/ benchmark took 1000000527 nanoseconds }, 1000);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_settimeout_cb_ms","title":"setTimeout(cb, ms)","description":"Run callback cb after at least ms milliseconds. The actual delay depends on external factors like OS timer granularity and system load.   The timeout must be in the range of 1-2,147,483,647 inclusive. If the value is outside that range, it&#39;s changed to 1 millisecond. Broadly speaking, a timer cannot span more than 24.8 days.   Returns an opaque value that represents the timer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cleartimeout_t","title":"clearTimeout(t)","description":"Stop a timer that was previously created with setTimeout(). The callback will not execute."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_setinterval_cb_ms","title":"setInterval(cb, ms)","description":"Run callback cb repeatedly every ms milliseconds. Note that the actual interval may vary, depending on external factors like OS timer granularity and system load. It&#39;s never less than ms but it may be longer.   The interval must be in the range of 1-2,147,483,647 inclusive. If the value is outside that range, it&#39;s changed to 1 millisecond. Broadly speaking, a timer cannot span more than 24.8 days.   Returns an opaque value that represents the timer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_about_this_documentation","title":"About this Documentation","description":"The goal of this documentation is to comprehensively explain the Node.js API, both from a reference as well as a conceptual point of view.  Each section describes a built-in module or high-level concept.   Where appropriate, property types, method arguments, and the arguments provided to event handlers are detailed in a list underneath the topic heading.   Every .html document has a corresponding .json document presenting the same information in a structured manner.  This feature is experimental, and added for the benefit of IDEs and other utilities that wish to do programmatic things with the documentation.   Every .html and .json file is generated based on the corresponding .markdown file in the doc\/api\/ folder in node&#39;s source tree.  The documentation is generated using the tools\/doc\/generate.js program. The HTML template is located at doc\/template.html."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stability_index","title":"Stability Index","description":"Throughout the documentation, you will see indications of a section&#39;s stability.  The Node.js API is still somewhat changing, and as it matures, certain parts are more reliable than others.  Some are so proven, and so relied upon, that they are unlikely to ever change at all.  Others are brand new and experimental, or known to be hazardous and in the process of being redesigned.   The stability indices are as follows:   Stability: 0 - Deprecated This feature is known to be problematic, and changes are planned.  Do not rely on it.  Use of the feature may cause warnings.  Backwards compatibility should not be expected. Stability: 1 - Experimental This feature was introduced recently, and may change or be removed in future versions.  Please try it out and provide feedback. If it addresses a use-case that is important to you, tell the node core team. Stability: 2 - Unstable The API is in the process of settling, but has not yet had sufficient real-world testing to be considered stable. Backwards-compatibility will be maintained if reasonable. Stability: 3 - Stable The API has proven satisfactory, but cleanup in the underlying code may cause minor changes.  Backwards-compatibility is guaranteed. Stability: 4 - API Frozen This API has been tested extensively in production and is unlikely to ever have to change. Stability: 5 - Locked Unless serious bugs are found, this code will not ever change.  Please do not suggest changes in this area; they will be refused."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_json_output","title":"JSON Output","description":"Every HTML file in the markdown has a corresponding JSON file with the same data.   This feature is new as of node v0.6.12.  It is experimental."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_synopsis","title":"Synopsis","description":"An example of a web server written with Node which responds with &#39;Hello World&#39;:   var http = require(&#39;http&#39;);  http.createServer(function (request, response) {   response.writeHead(200, {&#39;Content-Type&#39;: &#39;text\/plain&#39;});   response.end(&#39;Hello World\\n&#39;); }).listen(8124);  console.log(&#39;Server running at http:\/\/127.0.0.1:8124\/&#39;); To run the server, put the code into a file called example.js and execute it with the node program   > node example.js Server running at http:\/\/127.0.0.1:8124\/ All of the examples in the documentation can be run similarly."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_global_objects","title":"Global Objects","description":"These objects are available in all modules. Some of these objects aren&#39;t actually in the global scope but in the module scope - this will be noted."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_global","title":"global","description":"In browsers, the top-level scope is the global scope. That means that in browsers if you&#39;re in the global scope var something will define a global variable. In Node this is different. The top-level scope is not the global scope; var something inside a Node module will be local to that module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process","title":"process","description":"The process object. See the [process object][] section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console","title":"console","description":"Used to print to stdout and stderr. See the [stdio][] section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_class_buffer","title":"Class: Buffer","description":"Used to handle binary data. See the [buffer section][]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_clearinterval_t","title":"clearInterval(t)","description":"Stop a timer that was previously created with setInterval(). The callback will not execute.   The timer functions are global variables. See the [timers][] section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console","title":"console","description":"For printing to stdout and stderr.  Similar to the console object functions provided by most web browsers, here the output is sent to stdout or stderr."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_log_data","title":"console.log([data], [...])","description":"Prints to stdout with newline. This function can take multiple arguments in a printf()-like way. Example:   console.log(&#39;count: %d&#39;, count); If formatting elements are not found in the first string then util.inspect is used on each argument.  See [util.format()][] for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_info_data","title":"console.info([data], [...])","description":"Same as console.log."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_error_data","title":"console.error([data], [...])","description":"Same as console.log but prints to stderr."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_warn_data","title":"console.warn([data], [...])","description":"Same as console.error."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_dir_obj","title":"console.dir(obj)","description":"Uses util.inspect on obj and prints resulting string to stdout."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_time_label","title":"console.time(label)","description":"Mark a time."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_timeend_label","title":"console.timeEnd(label)","description":"Finish timer, record output. Example:   console.time(&#39;100-elements&#39;); for (var i = 0; i < 100; i++) {   ; } console.timeEnd(&#39;100-elements&#39;);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_trace_label","title":"console.trace(label)","description":"Print a stack trace to stderr of the current position."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_assert_expression_message","title":"console.assert(expression, [message])","description":"Same as [assert.ok()][] where if the expression evaluates as false throw an AssertionError with message."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process","title":"process","description":"The process object is a global object and can be accessed from anywhere. It is an instance of [EventEmitter][]."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_abort","title":"process.abort()","description":"This causes node to emit an abort. This will cause node to exit and generate a core file."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_chdir_directory","title":"process.chdir(directory)","description":"Changes the current working directory of the process or throws an exception if that fails.   console.log(&#39;Starting directory: &#39; + process.cwd()); try {   process.chdir(&#39;\/tmp&#39;);   console.log(&#39;New directory: &#39; + process.cwd()); } catch (err) {   console.log(&#39;chdir: &#39; + err); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_cwd","title":"process.cwd()","description":"Returns the current working directory of the process.   console.log(&#39;Current directory: &#39; + process.cwd());"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_exit_code","title":"process.exit([code])","description":"Ends the process with the specified code.  If omitted, exit uses the &#39;success&#39; code 0.   To exit with a &#39;failure&#39; code:   process.exit(1); The shell that executed node should see the exit code as 1."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_getgid","title":"process.getgid()","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Gets the group identity of the process. (See getgid(2).) This is the numerical group id, not the group name.   if (process.getgid) {   console.log(&#39;Current gid: &#39; + process.getgid()); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_setgid_id","title":"process.setgid(id)","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Sets the group identity of the process. (See setgid(2).)  This accepts either a numerical ID or a groupname string. If a groupname is specified, this method blocks while resolving it to a numerical ID.   if (process.getgid && process.setgid) {   console.log(&#39;Current gid: &#39; + process.getgid());   try {     process.setgid(501);     console.log(&#39;New gid: &#39; + process.getgid());   }   catch (err) {     console.log(&#39;Failed to set gid: &#39; + err);   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_getuid","title":"process.getuid()","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Gets the user identity of the process. (See getuid(2).) This is the numerical userid, not the username.   if (process.getuid) {   console.log(&#39;Current uid: &#39; + process.getuid()); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_setuid_id","title":"process.setuid(id)","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Sets the user identity of the process. (See setuid(2).)  This accepts either a numerical ID or a username string.  If a username is specified, this method blocks while resolving it to a numerical ID.   if (process.getuid && process.setuid) {   console.log(&#39;Current uid: &#39; + process.getuid());   try {     process.setuid(501);     console.log(&#39;New uid: &#39; + process.getuid());   }   catch (err) {     console.log(&#39;Failed to set uid: &#39; + err);   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_getgroups","title":"process.getgroups()","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Returns an array with the supplementary group IDs. POSIX leaves it unspecified if the effective group ID is included but node.js ensures it always is."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_setgroups_groups","title":"process.setgroups(groups)","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Sets the supplementary group IDs. This is a privileged operation, meaning you need to be root or have the CAP_SETGID capability.   The list can contain group IDs, group names or both."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_initgroups_user_extra_group","title":"process.initgroups(user, extra_group)","description":"Note: this function is only available on POSIX platforms (i.e. not Windows)   Reads \/etc\/group and initializes the group access list, using all groups of which the user is a member. This is a privileged operation, meaning you need to be root or have the CAP_SETGID capability.   user is a user name or user ID. extra_group is a group name or group ID.   Some care needs to be taken when dropping privileges. Example:   console.log(process.getgroups());         \/\/ [ 0 ] process.initgroups(&#39;bnoordhuis&#39;, 1000);   \/\/ switch user console.log(process.getgroups());         \/\/ [ 27, 30, 46, 1000, 0 ] process.setgid(1000);                     \/\/ drop root gid console.log(process.getgroups());         \/\/ [ 27, 30, 46, 1000 ]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_kill_pid_signal","title":"process.kill(pid, [signal])","description":"Send a signal to a process. pid is the process id and signal is the string describing the signal to send.  Signal names are strings like &#39;SIGINT&#39; or &#39;SIGUSR1&#39;.  If omitted, the signal will be &#39;SIGTERM&#39;. See kill(2) for more information.   Note that just because the name of this function is process.kill, it is really just a signal sender, like the kill system call.  The signal sent may do something other than kill the target process.   Example of sending a signal to yourself:   process.on(&#39;SIGHUP&#39;, function() {   console.log(&#39;Got SIGHUP signal.&#39;); });  setTimeout(function() {   console.log(&#39;Exiting.&#39;);   process.exit(0); }, 100);  process.kill(process.pid, &#39;SIGHUP&#39;);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_memoryusage","title":"process.memoryUsage()","description":"Returns an object describing the memory usage of the Node process measured in bytes.   var util = require(&#39;util&#39;);  console.log(util.inspect(process.memoryUsage())); This will generate:   { rss: 4935680,   heapTotal: 1826816,   heapUsed: 650472 } heapTotal and heapUsed refer to V8&#39;s memory usage."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_nexttick_callback","title":"process.nextTick(callback)","description":"On the next loop around the event loop call this callback. This is not a simple alias to setTimeout(fn, 0), it&#39;s much more efficient.  It typically runs before any other I\/O events fire, but there are some exceptions.  See process.maxTickDepth below.   process.nextTick(function() {   console.log(&#39;nextTick callback&#39;); }); This is important in developing APIs where you want to give the user the chance to assign event handlers after an object has been constructed, but before any I\/O has occurred.   function MyThing(options) {   this.setupOptions(options);    process.nextTick(function() {     this.startDoingStuff();   }.bind(this)); }  var thing = new MyThing(); thing.getReadyForStuff();  \/\/ thing.startDoingStuff() gets called now, not before. It is very important for APIs to be either 100% synchronous or 100% asynchronous.  Consider this example:   \/\/ WARNING!  DO NOT USE!  BAD UNSAFE HAZARD! function maybeSync(arg, cb) {   if (arg) {     cb();     return;   }    fs.stat(&#39;file&#39;, cb); } This API is hazardous.  If you do this:   maybeSync(true, function() {   foo(); }); bar(); then it&#39;s not clear whether foo() or bar() will be called first.   This approach is much better:   function definitelyAsync(arg, cb) {   if (arg) {     process.nextTick(cb);     return;   }    fs.stat(&#39;file&#39;, cb); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_umask_mask","title":"process.umask([mask])","description":"Sets or reads the process&#39;s file mode creation mask. Child processes inherit the mask from the parent process. Returns the old mask if mask argument is given, otherwise returns the current mask.   var oldmask, newmask = 0644;  oldmask = process.umask(newmask); console.log(&#39;Changed umask from: &#39; + oldmask.toString(8) +             &#39; to &#39; + newmask.toString(8));"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_uptime","title":"process.uptime()","description":"Number of seconds Node has been running."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_hrtime","title":"process.hrtime()","description":"Returns the current high-resolution real time in a [seconds, nanoseconds] tuple Array. It is relative to an arbitrary time in the past. It is not related to the time of day and therefore not subject to clock drift. The primary use is for measuring performance between intervals.   You may pass in the result of a previous call to process.hrtime() to get a diff reading, useful for benchmarks and measuring intervals:   var time = process.hrtime(); \/\/ [ 1800216, 25 ]  setTimeout(function() {   var diff = process.hrtime(time);   \/\/ [ 1, 552 ]    console.log(&#39;benchmark took %d nanoseconds&#39;, diff[0] * 1e9 + diff[1]);   \/\/ benchmark took 1000000527 nanoseconds }, 1000);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_settimeout_cb_ms","title":"setTimeout(cb, ms)","description":"Run callback cb after at least ms milliseconds. The actual delay depends on external factors like OS timer granularity and system load.   The timeout must be in the range of 1-2,147,483,647 inclusive. If the value is outside that range, it&#39;s changed to 1 millisecond. Broadly speaking, a timer cannot span more than 24.8 days.   Returns an opaque value that represents the timer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cleartimeout_t","title":"clearTimeout(t)","description":"Stop a timer that was previously created with setTimeout(). The callback will not execute."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_setinterval_cb_ms","title":"setInterval(cb, ms)","description":"Run callback cb repeatedly every ms milliseconds. Note that the actual interval may vary, depending on external factors like OS timer granularity and system load. It&#39;s never less than ms but it may be longer.   The interval must be in the range of 1-2,147,483,647 inclusive. If the value is outside that range, it&#39;s changed to 1 millisecond. Broadly speaking, a timer cannot span more than 24.8 days.   Returns an opaque value that represents the timer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_require","title":"require()","description":"To require modules. See the [Modules][] section.  require isn&#39;t actually a global but rather local to each module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_require_resolve","title":"require.resolve()","description":"Use the internal require() machinery to look up the location of a module, but rather than loading the module, just return the resolved filename."},{"url":"http:\/\/nodejs.org\/api\/all.html#all__filename","title":"__filename","description":"The filename of the code being executed.  This is the resolved absolute path of this code file.  For a main program this is not necessarily the same filename used in the command line.  The value inside a module is the path to that module file.   Example: running node example.js from \/Users\/mjr   console.log(__filename); \/\/ \/Users\/mjr\/example.js __filename isn&#39;t actually a global but rather local to each module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all__dirname","title":"__dirname","description":"The name of the directory that the currently executing script resides in.   Example: running node example.js from \/Users\/mjr   console.log(__dirname); \/\/ \/Users\/mjr __dirname isn&#39;t actually a global but rather local to each module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module","title":"module","description":"A reference to the current module. In particular module.exports is the same as the exports object. module isn&#39;t actually a global but rather local to each module.   See the [module system documentation][] for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_exports","title":"exports","description":"An object which is shared between all instances of the current module and made accessible through require(). exports is the same as the module.exports object. exports isn&#39;t actually a global but rather local to each module.   See the [module system documentation][] for more information.   See the [module section][] for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_debugger","title":"Debugger","description":"V8 comes with an extensive debugger which is accessible out-of-process via a simple TCP protocol. Node has a built-in client for this debugger. To use this, start Node with the debug argument; a prompt will appear:   % node debug myscript.js < debugger listening on port 5858 connecting... ok break in \/home\/indutny\/Code\/git\/indutny\/myscript.js:1   1 x = 5;   2 setTimeout(function () {   3   debugger; debug> Node&#39;s debugger client doesn&#39;t support the full range of commands, but simple step and inspection is possible. By putting the statement debugger; into the source code of your script, you will enable a breakpoint.   For example, suppose myscript.js looked like this:   \/\/ myscript.js x = 5; setTimeout(function () {   debugger;   console.log(\"world\"); }, 1000); console.log(\"hello\"); Then once the debugger is run, it will break on line 4.   % node debug myscript.js < debugger listening on port 5858 connecting... ok break in \/home\/indutny\/Code\/git\/indutny\/myscript.js:1   1 x = 5;   2 setTimeout(function () {   3   debugger; debug> cont < hello break in \/home\/indutny\/Code\/git\/indutny\/myscript.js:3   1 x = 5;   2 setTimeout(function () {   3   debugger;   4   console.log(\"world\");   5 }, 1000); debug> next break in \/home\/indutny\/Code\/git\/indutny\/myscript.js:4   2 setTimeout(function () {   3   debugger;   4   console.log(\"world\");   5 }, 1000);   6 console.log(\"hello\"); debug> repl Press Ctrl + C to leave debug repl > x 5 > 2+2 4 debug> next < world break in \/home\/indutny\/Code\/git\/indutny\/myscript.js:5   3   debugger;   4   console.log(\"world\");   5 }, 1000);   6 console.log(\"hello\");   7 debug> quit % The repl command allows you to evaluate code remotely. The next command steps over to the next line. There are a few other commands available and more to come. Type help to see others."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_watchers","title":"Watchers","description":"You can watch expression and variable values while debugging your code. On every breakpoint each expression from the watchers list will be evaluated in the current context and displayed just before the breakpoint&#39;s source code listing.   To start watching an expression, type watch(\"my_expression\"). watchers prints the active watchers. To remove a watcher, type unwatch(\"my_expression\")."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_commands_reference","title":"Commands reference","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_execution_control","title":"Execution control","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_various","title":"Various","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_advanced_usage","title":"Advanced Usage","description":"The V8 debugger can be enabled and accessed either by starting Node with the --debug command-line flag or by signaling an existing Node process with SIGUSR1.   Once a process has been set in debug mode with this it can be connected to with the node debugger. Either connect to the pid or the URI to the debugger. The syntax is:    node debug -p <pid> - Connects to the process via the pid `node debug  - Connects to the process via the URI such as localhost:5858"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_require","title":"require()","description":"To require modules. See the [Modules][] section.  require isn&#39;t actually a global but rather local to each module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_require_resolve","title":"require.resolve()","description":"Use the internal require() machinery to look up the location of a module, but rather than loading the module, just return the resolved filename."},{"url":"http:\/\/nodejs.org\/api\/all.html#all__filename","title":"__filename","description":"The filename of the code being executed.  This is the resolved absolute path of this code file.  For a main program this is not necessarily the same filename used in the command line.  The value inside a module is the path to that module file.   Example: running node example.js from \/Users\/mjr   console.log(__filename); \/\/ \/Users\/mjr\/example.js __filename isn&#39;t actually a global but rather local to each module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all__dirname","title":"__dirname","description":"The name of the directory that the currently executing script resides in.   Example: running node example.js from \/Users\/mjr   console.log(__dirname); \/\/ \/Users\/mjr __dirname isn&#39;t actually a global but rather local to each module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module","title":"module","description":"A reference to the current module. In particular module.exports is the same as the exports object. module isn&#39;t actually a global but rather local to each module.   See the [module system documentation][] for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_exports","title":"exports","description":"An object which is shared between all instances of the current module and made accessible through require(). exports is the same as the module.exports object. exports isn&#39;t actually a global but rather local to each module.   See the [module system documentation][] for more information.   See the [module section][] for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_timers","title":"Timers","description":"All of the timer functions are globals.  You do not need to require() this module in order to use them."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_settimeout_callback_delay_arg","title":"setTimeout(callback, delay, [arg], [...])","description":"To schedule execution of a one-time callback after delay milliseconds. Returns a timeoutId for possible use with clearTimeout(). Optionally you can also pass arguments to the callback.   It is important to note that your callback will probably not be called in exactly delay milliseconds - Node.js makes no guarantees about the exact timing of when the callback will fire, nor of the ordering things will fire in. The callback will be called as close as possible to the time specified."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cleartimeout_timeoutid","title":"clearTimeout(timeoutId)","description":"Prevents a timeout from triggering."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_setinterval_callback_delay_arg","title":"setInterval(callback, delay, [arg], [...])","description":"To schedule the repeated execution of callback every delay milliseconds. Returns a intervalId for possible use with clearInterval(). Optionally you can also pass arguments to the callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_clearinterval_intervalid","title":"clearInterval(intervalId)","description":"Stops a interval from triggering."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_unref","title":"unref()","description":"The opaque value returned by setTimeout and setInterval also has the method timer.unref() which will allow you to create a timer that is active but if it is the only item left in the event loop won&#39;t keep the program running. If the timer is already unrefd calling unref again will have no effect.   In the case of setTimeout when you unref you create a separate timer that will wakeup the event loop, creating too many of these may adversely effect event loop performance -- use wisely."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_ref","title":"ref()","description":"If you had previously unref()d a timer you can call ref() to explicitly request the timer hold the program open. If the timer is already refd calling ref again will have no effect."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_setimmediate_callback_arg","title":"setImmediate(callback, [arg], [...])","description":"To schedule the \"immediate\" execution of callback after I\/O events callbacks and before setTimeout and setInterval . Returns an immediateId for possible use with clearImmediate(). Optionally you can also pass arguments to the callback.   Immediates are queued in the order created, and are popped off the queue once per loop iteration. This is different from process.nextTick which will execute process.maxTickDepth queued callbacks per iteration. setImmediate will yield to the event loop after firing a queued callback to make sure I\/O is not being starved. While order is preserved for execution, other I\/O events may fire between any two scheduled immediate callbacks."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_clearimmediate_immediateid","title":"clearImmediate(immediateId)","description":"Stops an immediate from triggering."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_modules","title":"Modules","description":"Node has a simple module loading system.  In Node, files and modules are in one-to-one correspondence.  As an example, foo.js loads the module circle.js in the same directory.   The contents of foo.js:   var circle = require(&#39;.\/circle.js&#39;); console.log( &#39;The area of a circle of radius 4 is &#39;            + circle.area(4)); The contents of circle.js:   var PI = Math.PI;  exports.area = function (r) {   return PI * r * r; };  exports.circumference = function (r) {   return 2 * PI * r; }; The module circle.js has exported the functions area() and circumference().  To export an object, add to the special exports object.   Variables local to the module will be private. In this example the variable PI is private to circle.js.   The module system is implemented in the require(\"module\") module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cycles","title":"Cycles","description":"When there are circular require() calls, a module might not be done being executed when it is returned.   Consider this situation:   a.js:   console.log(&#39;a starting&#39;); exports.done = false; var b = require(&#39;.\/b.js&#39;); console.log(&#39;in a, b.done = %j&#39;, b.done); exports.done = true; console.log(&#39;a done&#39;); b.js:   console.log(&#39;b starting&#39;); exports.done = false; var a = require(&#39;.\/a.js&#39;); console.log(&#39;in b, a.done = %j&#39;, a.done); exports.done = true; console.log(&#39;b done&#39;); main.js:   console.log(&#39;main starting&#39;); var a = require(&#39;.\/a.js&#39;); var b = require(&#39;.\/b.js&#39;); console.log(&#39;in main, a.done=%j, b.done=%j&#39;, a.done, b.done); When main.js loads a.js, then a.js in turn loads b.js.  At that point, b.js tries to load a.js.  In order to prevent an infinite loop an unfinished copy of the a.js exports object is returned to the b.js module.  b.js then finishes loading, and its exports object is provided to the a.js module.   By the time main.js has loaded both modules, they&#39;re both finished. The output of this program would thus be:   $ node main.js main starting a starting b starting in b, a.done = false b done in a, b.done = true a done in main, a.done=true, b.done=true If you have cyclic module dependencies in your program, make sure to plan accordingly."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_core_modules","title":"Core Modules","description":"Node has several modules compiled into the binary.  These modules are described in greater detail elsewhere in this documentation.   The core modules are defined in node&#39;s source in the lib\/ folder.   Core modules are always preferentially loaded if their identifier is passed to require().  For instance, require(&#39;http&#39;) will always return the built in HTTP module, even if there is a file by that name."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_modules","title":"File Modules","description":"If the exact filename is not found, then node will attempt to load the required filename with the added extension of .js, .json, and then .node.   .js files are interpreted as JavaScript text files, and .json files are parsed as JSON text files. .node files are interpreted as compiled addon modules loaded with dlopen.   A module prefixed with &#39;\/&#39; is an absolute path to the file.  For example, require(&#39;\/home\/marco\/foo.js&#39;) will load the file at \/home\/marco\/foo.js.   A module prefixed with &#39;.\/&#39; is relative to the file calling require(). That is, circle.js must be in the same directory as foo.js for require(&#39;.\/circle&#39;) to find it.   Without a leading &#39;\/&#39; or &#39;.\/&#39; to indicate a file, the module is either a \"core module\" or is loaded from a node_modules folder.   If the given path does not exist, require() will throw an Error with its code property set to &#39;MODULE_NOT_FOUND&#39;."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_loading_from_node_modules_folders","title":"Loading from `node_modules` Folders","description":"If the module identifier passed to require() is not a native module, and does not begin with &#39;\/&#39;, &#39;..\/&#39;, or &#39;.\/&#39;, then node starts at the parent directory of the current module, and adds \/node_modules, and attempts to load the module from that location.   If it is not found there, then it moves to the parent directory, and so on, until the root of the tree is reached.   For example, if the file at &#39;\/home\/ry\/projects\/foo.js&#39; called require(&#39;bar.js&#39;), then node would look in the following locations, in this order:    \/home\/ry\/projects\/node_modules\/bar.js \/home\/ry\/node_modules\/bar.js \/home\/node_modules\/bar.js \/node_modules\/bar.js  This allows programs to localize their dependencies, so that they do not clash."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_folders_as_modules","title":"Folders as Modules","description":"It is convenient to organize programs and libraries into self-contained directories, and then provide a single entry point to that library. There are three ways in which a folder may be passed to require() as an argument.   The first is to create a package.json file in the root of the folder, which specifies a main module.  An example package.json file might look like this:   { \"name\" : \"some-library\",   \"main\" : \".\/lib\/some-library.js\" } If this was in a folder at .\/some-library, then require(&#39;.\/some-library&#39;) would attempt to load .\/some-library\/lib\/some-library.js.   This is the extent of Node&#39;s awareness of package.json files.   If there is no package.json file present in the directory, then node will attempt to load an index.js or index.node file out of that directory.  For example, if there was no package.json file in the above example, then require(&#39;.\/some-library&#39;) would attempt to load:    .\/some-library\/index.js .\/some-library\/index.node"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_caching","title":"Caching","description":"Modules are cached after the first time they are loaded.  This means (among other things) that every call to require(&#39;foo&#39;) will get exactly the same object returned, if it would resolve to the same file.   Multiple calls to require(&#39;foo&#39;) may not cause the module code to be executed multiple times.  This is an important feature.  With it, \"partially done\" objects can be returned, thus allowing transitive dependencies to be loaded even when they would cause cycles.   If you want to have a module execute code multiple times, then export a function, and call that function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module_caching_caveats","title":"Module Caching Caveats","description":"Modules are cached based on their resolved filename.  Since modules may resolve to a different filename based on the location of the calling module (loading from node_modules folders), it is not a guarantee that require(&#39;foo&#39;) will always return the exact same object, if it would resolve to different files."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_all_together","title":"All Together...","description":"To get the exact filename that will be loaded when require() is called, use the require.resolve() function.   Putting together all of the above, here is the high-level algorithm in pseudocode of what require.resolve does:   require(X) from module at path Y 1. If X is a core module,    a. return the core module    b. STOP 2. If X begins with &#39;.\/&#39; or &#39;\/&#39; or &#39;..\/&#39;    a. LOAD_AS_FILE(Y + X)    b. LOAD_AS_DIRECTORY(Y + X) 3. LOAD_NODE_MODULES(X, dirname(Y)) 4. THROW \"not found\"  LOAD_AS_FILE(X) 1. If X is a file, load X as JavaScript text.  STOP 2. If X.js is a file, load X.js as JavaScript text.  STOP 3. If X.node is a file, load X.node as binary addon.  STOP  LOAD_AS_DIRECTORY(X) 1. If X\/package.json is a file,    a. Parse X\/package.json, and look for \"main\" field.    b. let M = X + (json main field)    c. LOAD_AS_FILE(M) 2. If X\/index.js is a file, load X\/index.js as JavaScript text.  STOP 3. If X\/index.node is a file, load X\/index.node as binary addon.  STOP  LOAD_NODE_MODULES(X, START) 1. let DIRS=NODE_MODULES_PATHS(START) 2. for each DIR in DIRS:    a. LOAD_AS_FILE(DIR\/X)    b. LOAD_AS_DIRECTORY(DIR\/X)  NODE_MODULES_PATHS(START) 1. let PARTS = path split(START) 2. let ROOT = index of first instance of \"node_modules\" in PARTS, or 0 3. let I = count of PARTS - 1 4. let DIRS = [] 5. while I > ROOT,    a. if PARTS[I] = \"node_modules\" CONTINUE    c. DIR = path join(PARTS[0 .. I] + \"node_modules\")    b. DIRS = DIRS + DIR    c. let I = I - 1 6. return DIRS"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_loading_from_the_global_folders","title":"Loading from the global folders","description":"If the NODE_PATH environment variable is set to a colon-delimited list of absolute paths, then node will search those paths for modules if they are not found elsewhere.  (Note: On Windows, NODE_PATH is delimited by semicolons instead of colons.)   Additionally, node will search in the following locations:    1: $HOME\/.node_modules 2: $HOME\/.node_libraries 3: $PREFIX\/lib\/node  Where $HOME is the user&#39;s home directory, and $PREFIX is node&#39;s configured node_prefix.   These are mostly for historic reasons.  You are highly encouraged to place your dependencies locally in node_modules folders.  They will be loaded faster, and more reliably."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_accessing_the_main_module","title":"Accessing the main module","description":"When a file is run directly from Node, require.main is set to its module. That means that you can determine whether a file has been run directly by testing   require.main === module For a file foo.js, this will be true if run via node foo.js, but false if run by require(&#39;.\/foo&#39;).   Because module provides a filename property (normally equivalent to __filename), the entry point of the current application can be obtained by checking require.main.filename."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_addenda_package_manager_tips","title":"Addenda: Package Manager Tips","description":"The semantics of Node&#39;s require() function were designed to be general enough to support a number of sane directory structures. Package manager programs such as dpkg, rpm, and npm will hopefully find it possible to build native packages from Node modules without modification.   Below we give a suggested directory structure that could work:   Let&#39;s say that we wanted to have the folder at \/usr\/lib\/node\/<some-package>\/<some-version> hold the contents of a specific version of a package.   Packages can depend on one another. In order to install package foo, you may have to install a specific version of package bar.  The bar package may itself have dependencies, and in some cases, these dependencies may even collide or form cycles.   Since Node looks up the realpath of any modules it loads (that is, resolves symlinks), and then looks for their dependencies in the node_modules folders as described above, this situation is very simple to resolve with the following architecture:    \/usr\/lib\/node\/foo\/1.2.3\/ - Contents of the foo package, version 1.2.3. \/usr\/lib\/node\/bar\/4.3.2\/ - Contents of the bar package that foo depends on. \/usr\/lib\/node\/foo\/1.2.3\/node_modules\/bar - Symbolic link to \/usr\/lib\/node\/bar\/4.3.2\/. \/usr\/lib\/node\/bar\/4.3.2\/node_modules\/* - Symbolic links to the packages that bar depends on.  Thus, even if a cycle is encountered, or if there are dependency conflicts, every module will be able to get a version of its dependency that it can use.   When the code in the foo package does require(&#39;bar&#39;), it will get the version that is symlinked into \/usr\/lib\/node\/foo\/1.2.3\/node_modules\/bar. Then, when the code in the bar package calls require(&#39;quux&#39;), it&#39;ll get the version that is symlinked into \/usr\/lib\/node\/bar\/4.3.2\/node_modules\/quux.   Furthermore, to make the module lookup process even more optimal, rather than putting packages directly in \/usr\/lib\/node, we could put them in \/usr\/lib\/node_modules\/<name>\/<version>.  Then node will not bother looking for missing dependencies in \/usr\/node_modules or \/node_modules.   In order to make modules available to the node REPL, it might be useful to also add the \/usr\/lib\/node_modules folder to the $NODE_PATH environment variable.  Since the module lookups using node_modules folders are all relative, and based on the real path of the files making the calls to require(), the packages themselves can be anywhere."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_the_module_object","title":"The `module` Object","description":"In each module, the module free variable is a reference to the object representing the current module.  In particular module.exports is the same as the exports object. module isn&#39;t actually a global but rather local to each module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module_require_id","title":"module.require(id)","description":"The module.require method provides a way to load a module as if require() was called from the original module.   Note that in order to do this, you must get a reference to the module object.  Since require() returns the exports, and the module is typically only available within a specific module&#39;s code, it must be explicitly exported in order to be used."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_addons","title":"Addons","description":"Addons are dynamically linked shared objects. They can provide glue to C and C++ libraries. The API (at the moment) is rather complex, involving knowledge of several libraries:    V8 JavaScript, a C++ library. Used for interfacing with JavaScript: creating objects, calling functions, etc.  Documented mostly in the v8.h header file (deps\/v8\/include\/v8.h in the Node source tree), which is also available online.  libuv, C event loop library. Anytime one needs to wait for a file descriptor to become readable, wait for a timer, or wait for a signal to received one will need to interface with libuv. That is, if you perform any I\/O, libuv will need to be used.  Internal Node libraries. Most importantly is the node::ObjectWrap class which you will likely want to derive from.  Others. Look in deps\/ for what else is available.   Node statically compiles all its dependencies into the executable. When compiling your module, you don&#39;t need to worry about linking to any of these libraries.   All of the following examples are available for download and may be used as a starting-point for your own Addon."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_hello_world","title":"Hello world","description":"To get started let&#39;s make a small Addon which is the C++ equivalent of the following JavaScript code:   module.exports.hello = function() { return &#39;world&#39;; }; First we create a file hello.cc:   #include <node.h> #include <v8.h>  using namespace v8;  Handle<Value> Method(const Arguments& args) {   HandleScope scope;   return scope.Close(String::New(\"world\")); }  void init(Handle<Object> exports) {   exports->Set(String::NewSymbol(\"hello\"),       FunctionTemplate::New(Method)->GetFunction()); }  NODE_MODULE(hello, init) Note that all Node addons must export an initialization function:   void Initialize (Handle<Object> exports); NODE_MODULE(module_name, Initialize) There is no semi-colon after NODE_MODULE as it&#39;s not a function (see node.h).   The module_name needs to match the filename of the final binary (minus the .node suffix).   The source code needs to be built into hello.node, the binary Addon. To do this we create a file called binding.gyp which describes the configuration to build your module in a JSON-like format. This file gets compiled by node-gyp.   {   \"targets\": [     {       \"target_name\": \"hello\",       \"sources\": [ \"hello.cc\" ]     }   ] } The next step is to generate the appropriate project build files for the current platform. Use node-gyp configure for that.   Now you will have either a Makefile (on Unix platforms) or a vcxproj file (on Windows) in the build\/ directory. Next invoke the node-gyp build command.   Now you have your compiled .node bindings file! The compiled bindings end up in build\/Release\/.   You can now use the binary addon in a Node project hello.js by pointing require to the recently built hello.node module:   var addon = require(&#39;.\/build\/Release\/hello&#39;);  console.log(addon.hello()); \/\/ &#39;world&#39; Please see patterns below for further information or  https:\/\/github.com\/arturadib\/node-qt for an example in production."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_addon_patterns","title":"Addon patterns","description":"Below are some addon patterns to help you get started. Consult the online v8 reference for help with the various v8 calls, and v8&#39;s Embedder&#39;s Guide for an explanation of several concepts used such as handles, scopes, function templates, etc.   In order to use these examples you need to compile them using node-gyp. Create the following binding.gyp file:   {   \"targets\": [     {       \"target_name\": \"addon\",       \"sources\": [ \"addon.cc\" ]     }   ] } In cases where there is more than one .cc file, simply add the file name to the sources array, e.g.:   \"sources\": [\"addon.cc\", \"myexample.cc\"] Now that you have your binding.gyp ready, you can configure and build the addon:   $ node-gyp configure build"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_function_arguments","title":"Function arguments","description":"The following pattern illustrates how to read arguments from JavaScript function calls and return a result. This is the main and only needed source addon.cc:   #define BUILDING_NODE_EXTENSION #include <node.h>  using namespace v8;  Handle<Value> Add(const Arguments& args) {   HandleScope scope;    if (args.Length() < 2) {     ThrowException(Exception::TypeError(String::New(\"Wrong number of arguments\")));     return scope.Close(Undefined());   }    if (!args[0]->IsNumber() || !args[1]->IsNumber()) {     ThrowException(Exception::TypeError(String::New(\"Wrong arguments\")));     return scope.Close(Undefined());   }    Local<Number> num = Number::New(args[0]->NumberValue() +       args[1]->NumberValue());   return scope.Close(num); }  void Init(Handle<Object> exports) {   exports->Set(String::NewSymbol(\"add\"),       FunctionTemplate::New(Add)->GetFunction()); }  NODE_MODULE(addon, Init) You can test it with the following JavaScript snippet:   var addon = require(&#39;.\/build\/Release\/addon&#39;);  console.log( &#39;This should be eight:&#39;, addon.add(3,5) );"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_callbacks","title":"Callbacks","description":"You can pass JavaScript functions to a C++ function and execute them from there. Here&#39;s addon.cc:   #define BUILDING_NODE_EXTENSION #include <node.h>  using namespace v8;  Handle<Value> RunCallback(const Arguments& args) {   HandleScope scope;    Local<Function> cb = Local<Function>::Cast(args[0]);   const unsigned argc = 1;   Local<Value> argv[argc] = { Local<Value>::New(String::New(\"hello world\")) };   cb->Call(Context::GetCurrent()->Global(), argc, argv);    return scope.Close(Undefined()); }  void Init(Handle<Object> exports, Handle<Object> module) {   module->Set(String::NewSymbol(\"exports\"),       FunctionTemplate::New(RunCallback)->GetFunction()); }  NODE_MODULE(addon, Init) Note that this example uses a two-argument form of Init() that receives the full module object as the second argument. This allows the addon to completely overwrite exports with a single function instead of adding the function as a property of exports.   To test it run the following JavaScript snippet:   var addon = require(&#39;.\/build\/Release\/addon&#39;);  addon(function(msg){   console.log(msg); \/\/ &#39;hello world&#39; });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_object_factory","title":"Object factory","description":"You can create and return new objects from within a C++ function with this addon.cc pattern, which returns an object with property msg that echoes the string passed to createObject():   #define BUILDING_NODE_EXTENSION #include <node.h>  using namespace v8;  Handle<Value> CreateObject(const Arguments& args) {   HandleScope scope;    Local<Object> obj = Object::New();   obj->Set(String::NewSymbol(\"msg\"), args[0]->ToString());    return scope.Close(obj); }  void Init(Handle<Object> exports, Handle<Object> module) {   module->Set(String::NewSymbol(\"exports\"),       FunctionTemplate::New(CreateObject)->GetFunction()); }  NODE_MODULE(addon, Init) To test it in JavaScript:   var addon = require(&#39;.\/build\/Release\/addon&#39;);  var obj1 = addon(&#39;hello&#39;); var obj2 = addon(&#39;world&#39;); console.log(obj1.msg+&#39; &#39;+obj2.msg); \/\/ &#39;hello world&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_function_factory","title":"Function factory","description":"This pattern illustrates how to create and return a JavaScript function that wraps a C++ function:   #define BUILDING_NODE_EXTENSION #include <node.h>  using namespace v8;  Handle<Value> MyFunction(const Arguments& args) {   HandleScope scope;   return scope.Close(String::New(\"hello world\")); }  Handle<Value> CreateFunction(const Arguments& args) {   HandleScope scope;    Local<FunctionTemplate> tpl = FunctionTemplate::New(MyFunction);   Local<Function> fn = tpl->GetFunction();   fn->SetName(String::NewSymbol(\"theFunction\")); \/\/ omit this to make it anonymous    return scope.Close(fn); }  void Init(Handle<Object> exports, Handle<Object> module) {   module->Set(String::NewSymbol(\"exports\"),       FunctionTemplate::New(CreateFunction)->GetFunction()); }  NODE_MODULE(addon, Init) To test:   var addon = require(&#39;.\/build\/Release\/addon&#39;);  var fn = addon(); console.log(fn()); \/\/ &#39;hello world&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_wrapping_c_objects","title":"Wrapping C++ objects","description":"Here we will create a wrapper for a C++ object\/class MyObject that can be instantiated in JavaScript through the new operator. First prepare the main module addon.cc:   #define BUILDING_NODE_EXTENSION #include <node.h> #include \"myobject.h\"  using namespace v8;  void InitAll(Handle<Object> exports) {   MyObject::Init(exports); }  NODE_MODULE(addon, InitAll) Then in myobject.h make your wrapper inherit from node::ObjectWrap:   #ifndef MYOBJECT_H #define MYOBJECT_H  #include <node.h>  class MyObject : public node::ObjectWrap {  public:   static void Init(v8::Handle<v8::Object> exports);   private:   MyObject();   ~MyObject();    static v8::Handle<v8::Value> New(const v8::Arguments& args);   static v8::Handle<v8::Value> PlusOne(const v8::Arguments& args);   double counter_; };  #endif And in myobject.cc implement the various methods that you want to expose. Here we expose the method plusOne by adding it to the constructor&#39;s prototype:   #define BUILDING_NODE_EXTENSION #include <node.h> #include \"myobject.h\"  using namespace v8;  MyObject::MyObject() {}; MyObject::~MyObject() {};  void MyObject::Init(Handle<Object> exports) {   \/\/ Prepare constructor template   Local<FunctionTemplate> tpl = FunctionTemplate::New(New);   tpl->SetClassName(String::NewSymbol(\"MyObject\"));   tpl->InstanceTemplate()->SetInternalFieldCount(1);   \/\/ Prototype   tpl->PrototypeTemplate()->Set(String::NewSymbol(\"plusOne\"),       FunctionTemplate::New(PlusOne)->GetFunction());    Persistent<Function> constructor = Persistent<Function>::New(tpl->GetFunction());   exports->Set(String::NewSymbol(\"MyObject\"), constructor); }  Handle<Value> MyObject::New(const Arguments& args) {   HandleScope scope;    MyObject* obj = new MyObject();   obj->counter_ = args[0]->IsUndefined() ? 0 : args[0]->NumberValue();   obj->Wrap(args.This());    return args.This(); }  Handle<Value> MyObject::PlusOne(const Arguments& args) {   HandleScope scope;    MyObject* obj = ObjectWrap::Unwrap<MyObject>(args.This());   obj->counter_ += 1;    return scope.Close(Number::New(obj->counter_)); } Test it with:   var addon = require(&#39;.\/build\/Release\/addon&#39;);  var obj = new addon.MyObject(10); console.log( obj.plusOne() ); \/\/ 11 console.log( obj.plusOne() ); \/\/ 12 console.log( obj.plusOne() ); \/\/ 13"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_factory_of_wrapped_objects","title":"Factory of wrapped objects","description":"This is useful when you want to be able to create native objects without explicitly instantiating them with the new operator in JavaScript, e.g.   var obj = addon.createObject(); \/\/ instead of: \/\/ var obj = new addon.Object(); Let&#39;s register our createObject method in addon.cc:   #define BUILDING_NODE_EXTENSION #include <node.h> #include \"myobject.h\"  using namespace v8;  Handle<Value> CreateObject(const Arguments& args) {   HandleScope scope;   return scope.Close(MyObject::NewInstance(args)); }  void InitAll(Handle<Object> exports, Handle<Object> module) {   MyObject::Init();    module->Set(String::NewSymbol(\"exports\"),       FunctionTemplate::New(CreateObject)->GetFunction()); }  NODE_MODULE(addon, InitAll) In myobject.h we now introduce the static method NewInstance that takes care of instantiating the object (i.e. it does the job of new in JavaScript):   #define BUILDING_NODE_EXTENSION #ifndef MYOBJECT_H #define MYOBJECT_H  #include <node.h>  class MyObject : public node::ObjectWrap {  public:   static void Init();   static v8::Handle<v8::Value> NewInstance(const v8::Arguments& args);   private:   MyObject();   ~MyObject();    static v8::Persistent<v8::Function> constructor;   static v8::Handle<v8::Value> New(const v8::Arguments& args);   static v8::Handle<v8::Value> PlusOne(const v8::Arguments& args);   double counter_; };  #endif The implementation is similar to the above in myobject.cc:   #define BUILDING_NODE_EXTENSION #include <node.h> #include \"myobject.h\"  using namespace v8;  MyObject::MyObject() {}; MyObject::~MyObject() {};  Persistent<Function> MyObject::constructor;  void MyObject::Init() {   \/\/ Prepare constructor template   Local<FunctionTemplate> tpl = FunctionTemplate::New(New);   tpl->SetClassName(String::NewSymbol(\"MyObject\"));   tpl->InstanceTemplate()->SetInternalFieldCount(1);   \/\/ Prototype   tpl->PrototypeTemplate()->Set(String::NewSymbol(\"plusOne\"),       FunctionTemplate::New(PlusOne)->GetFunction());    constructor = Persistent<Function>::New(tpl->GetFunction()); }  Handle<Value> MyObject::New(const Arguments& args) {   HandleScope scope;    MyObject* obj = new MyObject();   obj->counter_ = args[0]->IsUndefined() ? 0 : args[0]->NumberValue();   obj->Wrap(args.This());    return args.This(); }  Handle<Value> MyObject::NewInstance(const Arguments& args) {   HandleScope scope;    const unsigned argc = 1;   Handle<Value> argv[argc] = { args[0] };   Local<Object> instance = constructor->NewInstance(argc, argv);    return scope.Close(instance); }  Handle<Value> MyObject::PlusOne(const Arguments& args) {   HandleScope scope;    MyObject* obj = ObjectWrap::Unwrap<MyObject>(args.This());   obj->counter_ += 1;    return scope.Close(Number::New(obj->counter_)); } Test it with:   var createObject = require(&#39;.\/build\/Release\/addon&#39;);  var obj = createObject(10); console.log( obj.plusOne() ); \/\/ 11 console.log( obj.plusOne() ); \/\/ 12 console.log( obj.plusOne() ); \/\/ 13  var obj2 = createObject(20); console.log( obj2.plusOne() ); \/\/ 21 console.log( obj2.plusOne() ); \/\/ 22 console.log( obj2.plusOne() ); \/\/ 23"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_passing_wrapped_objects_around","title":"Passing wrapped objects around","description":"In addition to wrapping and returning C++ objects, you can pass them around by unwrapping them with Node&#39;s node::ObjectWrap::Unwrap helper function. In the following addon.cc we introduce a function add() that can take on two MyObject objects:   #define BUILDING_NODE_EXTENSION #include <node.h> #include \"myobject.h\"  using namespace v8;  Handle<Value> CreateObject(const Arguments& args) {   HandleScope scope;   return scope.Close(MyObject::NewInstance(args)); }  Handle<Value> Add(const Arguments& args) {   HandleScope scope;    MyObject* obj1 = node::ObjectWrap::Unwrap<MyObject>(       args[0]->ToObject());   MyObject* obj2 = node::ObjectWrap::Unwrap<MyObject>(       args[1]->ToObject());    double sum = obj1->Val() + obj2->Val();   return scope.Close(Number::New(sum)); }  void InitAll(Handle<Object> exports) {   MyObject::Init();    exports->Set(String::NewSymbol(\"createObject\"),       FunctionTemplate::New(CreateObject)->GetFunction());    exports->Set(String::NewSymbol(\"add\"),       FunctionTemplate::New(Add)->GetFunction()); }  NODE_MODULE(addon, InitAll) To make things interesting we introduce a public method in myobject.h so we can probe private values after unwrapping the object:   #define BUILDING_NODE_EXTENSION #ifndef MYOBJECT_H #define MYOBJECT_H  #include <node.h>  class MyObject : public node::ObjectWrap {  public:   static void Init();   static v8::Handle<v8::Value> NewInstance(const v8::Arguments& args);   double Val() const { return val_; }   private:   MyObject();   ~MyObject();    static v8::Persistent<v8::Function> constructor;   static v8::Handle<v8::Value> New(const v8::Arguments& args);   double val_; };  #endif The implementation of myobject.cc is similar as before:   #define BUILDING_NODE_EXTENSION #include <node.h> #include \"myobject.h\"  using namespace v8;  MyObject::MyObject() {}; MyObject::~MyObject() {};  Persistent<Function> MyObject::constructor;  void MyObject::Init() {   \/\/ Prepare constructor template   Local<FunctionTemplate> tpl = FunctionTemplate::New(New);   tpl->SetClassName(String::NewSymbol(\"MyObject\"));   tpl->InstanceTemplate()->SetInternalFieldCount(1);    constructor = Persistent<Function>::New(tpl->GetFunction()); }  Handle<Value> MyObject::New(const Arguments& args) {   HandleScope scope;    MyObject* obj = new MyObject();   obj->val_ = args[0]->IsUndefined() ? 0 : args[0]->NumberValue();   obj->Wrap(args.This());    return args.This(); }  Handle<Value> MyObject::NewInstance(const Arguments& args) {   HandleScope scope;    const unsigned argc = 1;   Handle<Value> argv[argc] = { args[0] };   Local<Object> instance = constructor->NewInstance(argc, argv);    return scope.Close(instance); } Test it with:   var addon = require(&#39;.\/build\/Release\/addon&#39;);  var obj1 = addon.createObject(10); var obj2 = addon.createObject(20); var result = addon.add(obj1, obj2);  console.log(result); \/\/ 30"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util","title":"util","description":"These functions are in the module &#39;util&#39;. Use require(&#39;util&#39;) to access them."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_format_format","title":"util.format(format, [...])","description":"Returns a formatted string using the first argument as a printf-like format.   The first argument is a string that contains zero or more placeholders. Each placeholder is replaced with the converted value from its corresponding argument. Supported placeholders are:    %s - String. %d - Number (both integer and float). %j - JSON. % - single percent sign (&#39;%&#39;). This does not consume an argument.  If the placeholder does not have a corresponding argument, the placeholder is not replaced.   util.format(&#39;%s:%s&#39;, &#39;foo&#39;); \/\/ &#39;foo:%s&#39; If there are more arguments than placeholders, the extra arguments are converted to strings with util.inspect() and these strings are concatenated, delimited by a space.   util.format(&#39;%s:%s&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;); \/\/ &#39;foo:bar baz&#39; If the first argument is not a format string then util.format() returns a string that is the concatenation of all its arguments separated by spaces. Each argument is converted to a string with util.inspect().   util.format(1, 2, 3); \/\/ &#39;1 2 3&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_debug_string","title":"util.debug(string)","description":"A synchronous output function. Will block the process and output string immediately to stderr.   require(&#39;util&#39;).debug(&#39;message on stderr&#39;);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_error","title":"util.error([...])","description":"Same as util.debug() except this will output all arguments immediately to stderr."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_puts","title":"util.puts([...])","description":"A synchronous output function. Will block the process and output all arguments to stdout with newlines after each argument."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_print","title":"util.print([...])","description":"A synchronous output function. Will block the process, cast each argument to a string then output to stdout. Does not place newlines after each argument."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_log_string","title":"util.log(string)","description":"Output with timestamp on stdout.   require(&#39;util&#39;).log(&#39;Timestamped message.&#39;);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_inspect_object_options","title":"util.inspect(object, [options])","description":"Return a string representation of object, which is useful for debugging.   An optional options object may be passed that alters certain aspects of the formatted string:    showHidden - if true then the object&#39;s non-enumerable properties will be shown too. Defaults to false.  depth - tells inspect how many times to recurse while formatting the object. This is useful for inspecting large complicated objects. Defaults to 2. To make it recurse indefinitely pass null.  colors - if true, then the output will be styled with ANSI color codes. Defaults to false. Colors are customizable, see below.  customInspect - if false, then custom inspect() functions defined on the objects being inspected won&#39;t be called. Defaults to true.   Example of inspecting all properties of the util object:   var util = require(&#39;util&#39;);  console.log(util.inspect(util, { showHidden: true, depth: null }));"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_customizing_util_inspect_colors","title":"Customizing `util.inspect` colors","description":"Color output (if enabled) of util.inspect is customizable globally via util.inspect.styles and util.inspect.colors objects.   util.inspect.styles is a map assigning each style a color from util.inspect.colors. Highlighted styles and their default values are:   number (yellow)   boolean (yellow)   string (green)   date (magenta)   regexp (red)   null (bold)   undefined (grey)   special - only function at this time (cyan)  * name (intentionally no styling)   Predefined color codes are: white, grey, black, blue, cyan,  green, magenta, red and yellow. There are also bold, italic, underline and inverse codes.   Objects also may define their own inspect(depth) function which util.inspect() will invoke and use the result of when inspecting the object:   var util = require(&#39;util&#39;);  var obj = { name: &#39;nate&#39; }; obj.inspect = function(depth) {   return &#39;{&#39; + this.name + &#39;}&#39;; };  util.inspect(obj);   \/\/ \"{nate}\""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isarray_object","title":"util.isArray(object)","description":"Returns true if the given \"object\" is an Array. false otherwise.   var util = require(&#39;util&#39;);  util.isArray([])   \/\/ true util.isArray(new Array)   \/\/ true util.isArray({})   \/\/ false"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isregexp_object","title":"util.isRegExp(object)","description":"Returns true if the given \"object\" is a RegExp. false otherwise.   var util = require(&#39;util&#39;);  util.isRegExp(\/some regexp\/)   \/\/ true util.isRegExp(new RegExp(&#39;another regexp&#39;))   \/\/ true util.isRegExp({})   \/\/ false"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isdate_object","title":"util.isDate(object)","description":"Returns true if the given \"object\" is a Date. false otherwise.   var util = require(&#39;util&#39;);  util.isDate(new Date())   \/\/ true util.isDate(Date())   \/\/ false (without &#39;new&#39; returns a String) util.isDate({})   \/\/ false"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_iserror_object","title":"util.isError(object)","description":"Returns true if the given \"object\" is an Error. false otherwise.   var util = require(&#39;util&#39;);  util.isError(new Error())   \/\/ true util.isError(new TypeError())   \/\/ true util.isError({ name: &#39;Error&#39;, message: &#39;an error occurred&#39; })   \/\/ false"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_pump_readablestream_writablestream_callback","title":"util.pump(readableStream, writableStream, [callback])","description":"Read the data from readableStream and send it to the writableStream. When writableStream.write(data) returns false readableStream will be paused until the drain event occurs on the writableStream. callback gets an error as its only argument and is called when writableStream is closed or when an error occurs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_inherits_constructor_superconstructor","title":"util.inherits(constructor, superConstructor)","description":"Inherit the prototype methods from one constructor into another.  The prototype of constructor will be set to a new object created from superConstructor.   As an additional convenience, superConstructor will be accessible through the constructor.super_ property.   var util = require(\"util\"); var events = require(\"events\");  function MyStream() {     events.EventEmitter.call(this); }  util.inherits(MyStream, events.EventEmitter);  MyStream.prototype.write = function(data) {     this.emit(\"data\", data); }  var stream = new MyStream();  console.log(stream instanceof events.EventEmitter); \/\/ true console.log(MyStream.super_ === events.EventEmitter); \/\/ true  stream.on(\"data\", function(data) {     console.log(&#39;Received data: \"&#39; + data + &#39;\"&#39;); }) stream.write(\"It works!\"); \/\/ Received data: \"It works!\""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_events","title":"Events","description":"Many objects in Node emit events: a net.Server emits an event each time a peer connects to it, a fs.readStream emits an event when the file is opened. All objects which emit events are instances of events.EventEmitter. You can access this module by doing: require(\"events\");   Typically, event names are represented by a camel-cased string, however, there aren&#39;t any strict restrictions on that, as any string will be accepted.   Functions can then be attached to objects, to be executed when an event is emitted. These functions are called listeners."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_domain","title":"Domain","description":"Domains provide a way to handle multiple different IO operations as a single group.  If any of the event emitters or callbacks registered to a domain emit an error event, or throw an error, then the domain object will be notified, rather than losing the context of the error in the process.on(&#39;uncaughtException&#39;) handler, or causing the program to exit with an error code.   This feature is new in Node version 0.8.  It is a first pass, and is expected to change significantly in future versions.  Please use it and provide feedback.   Due to their experimental nature, the Domains features are disabled unless the domain module is loaded at least once.  No domains are created or registered by default.  This is by design, to prevent adverse effects on current programs.  It is expected to be enabled by default in future Node.js versions."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_domain_create","title":"domain.create()","description":"Returns a new Domain object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_additions_to_error_objects","title":"Additions to Error objects","description":"Any time an Error object is routed through a domain, a few extra fields are added to it.    error.domain The domain that first handled the error. error.domainEmitter The event emitter that emitted an &#39;error&#39; event with the error object. error.domainBound The callback function which was bound to the domain, and passed an error as its first argument. error.domainThrown A boolean indicating whether the error was thrown, emitted, or passed to a bound callback function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_implicit_binding","title":"Implicit Binding","description":"If domains are in use, then all new EventEmitter objects (including Stream objects, requests, responses, etc.) will be implicitly bound to the active domain at the time of their creation.   Additionally, callbacks passed to lowlevel event loop requests (such as to fs.open, or other callback-taking methods) will automatically be bound to the active domain.  If they throw, then the domain will catch the error.   In order to prevent excessive memory usage, Domain objects themselves are not implicitly added as children of the active domain.  If they were, then it would be too easy to prevent request and response objects from being properly garbage collected.   If you want to nest Domain objects as children of a parent Domain, then you must explicitly add them, and then dispose of them later.   Implicit binding routes thrown errors and &#39;error&#39; events to the Domain&#39;s error event, but does not register the EventEmitter on the Domain, so domain.dispose() will not shut down the EventEmitter. Implicit binding only takes care of thrown errors and &#39;error&#39; events."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_explicit_binding","title":"Explicit Binding","description":"Sometimes, the domain in use is not the one that ought to be used for a specific event emitter.  Or, the event emitter could have been created in the context of one domain, but ought to instead be bound to some other domain.   For example, there could be one domain in use for an HTTP server, but perhaps we would like to have a separate domain to use for each request.   That is possible via explicit binding.   For example:   \/\/ create a top-level domain for the server var serverDomain = domain.create();  serverDomain.run(function() {   \/\/ server is created in the scope of serverDomain   http.createServer(function(req, res) {     \/\/ req and res are also created in the scope of serverDomain     \/\/ however, we&#39;d prefer to have a separate domain for each request.     \/\/ create it first thing, and add req and res to it.     var reqd = domain.create();     reqd.add(req);     reqd.add(res);     reqd.on(&#39;error&#39;, function(er) {       console.error(&#39;Error&#39;, er, req.url);       try {         res.writeHead(500);         res.end(&#39;Error occurred, sorry.&#39;);         res.on(&#39;close&#39;, function() {           \/\/ forcibly shut down any other things added to this domain           reqd.dispose();         });       } catch (er) {         console.error(&#39;Error sending 500&#39;, er, req.url);         \/\/ tried our best.  clean up anything remaining.         reqd.dispose();       }     });   }).listen(1337); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_buffer","title":"Buffer","description":"Pure JavaScript is Unicode friendly but not nice to binary data.  When dealing with TCP streams or the file system, it&#39;s necessary to handle octet streams. Node has several strategies for manipulating, creating, and consuming octet streams.   Raw data is stored in instances of the Buffer class. A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap. A Buffer cannot be resized.   The Buffer class is a global, making it very rare that one would need to ever require(&#39;buffer&#39;).   Converting between Buffers and JavaScript string objects requires an explicit encoding method.  Here are the different string encodings.    &#39;ascii&#39; - for 7 bit ASCII data only.  This encoding method is very fast, and will strip the high bit if set. Note that when converting from string to buffer, this encoding converts a null character (&#39;\\0&#39; or &#39;\\u0000&#39;) into 0x20 (character code of a space). If you want to convert a null character into 0x00, you should use &#39;utf8&#39;.  &#39;utf8&#39; - Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.  &#39;utf16le&#39; - 2 or 4 bytes, little endian encoded Unicode characters. Surrogate pairs (U+10000 to U+10FFFF) are supported.  &#39;ucs2&#39; - Alias of &#39;utf16le&#39;.  &#39;base64&#39; - Base64 string encoding.  &#39;binary&#39; - A way of encoding raw binary data into strings by using only the first 8 bits of each character. This encoding method is deprecated and should be avoided in favor of Buffer objects where possible. This encoding will be removed in future versions of Node.  &#39;hex&#39; - Encode each byte as two hexadecimal characters.   A Buffer object can also be used with typed arrays.  The buffer object is cloned to an ArrayBuffer that is used as the backing store for the typed array.  The memory of the buffer and the ArrayBuffer is not shared.   NOTE: Node.js v0.8 simply retained a reference to the buffer in array.buffer instead of cloning it.   While more efficient, it introduces subtle incompatibilities with the typed arrays specification.  ArrayBuffer#slice() makes a copy of the slice while Buffer#slice() creates a view."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stream","title":"Stream","description":"A stream is an abstract interface implemented by various objects in Node.  For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of [EventEmitter][]   You can load the Stream base classes by doing require(&#39;stream&#39;). There are base classes provided for Readable streams, Writable streams, Duplex streams, and Transform streams."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_compatibility","title":"Compatibility","description":"In earlier versions of Node, the Readable stream interface was simpler, but also less powerful and less useful.    Rather than waiting for you to call the read() method, &#39;data&#39; events would start emitting immediately.  If you needed to do some I\/O to decide how to handle data, then you had to store the chunks in some kind of buffer so that they would not be lost. The pause() method was advisory, rather than guaranteed.  This meant that you still had to be prepared to receive &#39;data&#39; events even when the stream was in a paused state.  In Node v0.10, the Readable class described below was added.  For backwards compatibility with older Node programs, Readable streams switch into \"old mode\" when a &#39;data&#39; event handler is added, or when the pause() or resume() methods are called.  The effect is that, even if you are not using the new read() method and &#39;readable&#39; event, you no longer have to worry about losing &#39;data&#39; chunks.   Most programs will continue to function normally.  However, this introduces an edge case in the following conditions:    No &#39;data&#39; event handler is added. The pause() and resume() methods are never called.  For example, consider the following code:   \/\/ WARNING!  BROKEN! net.createServer(function(socket) {    \/\/ we add an &#39;end&#39; method, but never consume the data   socket.on(&#39;end&#39;, function() {     \/\/ It will never get here.     socket.end(&#39;I got your message (but didnt read it)\\n&#39;);   });  }).listen(1337); In versions of node prior to v0.10, the incoming message data would be simply discarded.  However, in Node v0.10 and beyond, the socket will remain paused forever.   The workaround in this situation is to call the resume() method to trigger \"old mode\" behavior:   \/\/ Workaround net.createServer(function(socket) {    socket.on(&#39;end&#39;, function() {     socket.end(&#39;I got your message (but didnt read it)\\n&#39;);   });    \/\/ start the flow of data, discarding it.   socket.resume();  }).listen(1337); In addition to new Readable streams switching into old-mode, pre-v0.10 style streams can be wrapped in a Readable class using the wrap() method."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto","title":"Crypto","description":"Stability: 2 - Unstable; API changes are being discussed for future versions.  Breaking changes will be minimized.  See below. Use require(&#39;crypto&#39;) to access this module.   The crypto module offers a way of encapsulating secure credentials to be used as part of a secure HTTPS net or http connection.   It also offers a set of wrappers for OpenSSL&#39;s hash, hmac, cipher, decipher, sign and verify methods."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_getciphers","title":"crypto.getCiphers()","description":"Returns an array with the names of the supported ciphers.   Example:   var ciphers = crypto.getCiphers(); console.log(ciphers); \/\/ [&#39;AES128-SHA&#39;, &#39;AES256-SHA&#39;, ...]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_gethashes","title":"crypto.getHashes()","description":"Returns an array with the names of the supported hash algorithms.   Example:   var hashes = crypto.getHashes(); console.log(hashes); \/\/ [&#39;sha&#39;, &#39;sha1&#39;, &#39;sha1WithRSAEncryption&#39;, ...]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createcredentials_details","title":"crypto.createCredentials(details)","description":"Creates a credentials object, with the optional details being a dictionary with keys:    pfx : A string or buffer holding the PFX or PKCS12 encoded private key, certificate and CA certificates key : A string holding the PEM encoded private key passphrase : A string of passphrase for the private key or pfx cert : A string holding the PEM encoded certificate ca : Either a string or list of strings of PEM encoded CA certificates to trust. crl : Either a string or list of strings of PEM encoded CRLs (Certificate Revocation List) ciphers: A string describing the ciphers to use or exclude. Consult http:\/\/www.openssl.org\/docs\/apps\/ciphers.html#CIPHER_LIST_FORMAT for details on the format.  If no &#39;ca&#39; details are given, then node.js will use the default publicly trusted list of CAs as given in  http:\/\/mxr.mozilla.org\/mozilla\/source\/security\/nss\/lib\/ckfw\/builtins\/certdata.txt."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createhash_algorithm","title":"crypto.createHash(algorithm)","description":"Creates and returns a hash object, a cryptographic hash with the given algorithm which can be used to generate hash digests.   algorithm is dependent on the available algorithms supported by the version of OpenSSL on the platform. Examples are &#39;sha1&#39;, &#39;md5&#39;, &#39;sha256&#39;, &#39;sha512&#39;, etc.  On recent releases, openssl list-message-digest-algorithms will display the available digest algorithms.   Example: this program that takes the sha1 sum of a file   var filename = process.argv[2]; var crypto = require(&#39;crypto&#39;); var fs = require(&#39;fs&#39;);  var shasum = crypto.createHash(&#39;sha1&#39;);  var s = fs.ReadStream(filename); s.on(&#39;data&#39;, function(d) {   shasum.update(d); });  s.on(&#39;end&#39;, function() {   var d = shasum.digest(&#39;hex&#39;);   console.log(d + &#39;  &#39; + filename); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createhmac_algorithm_key","title":"crypto.createHmac(algorithm, key)","description":"Creates and returns a hmac object, a cryptographic hmac with the given algorithm and key.   It is a stream that is both readable and writable.  The written data is used to compute the hmac.  Once the writable side of the stream is ended, use the read() method to get the computed digest.  The legacy update and digest methods are also supported.   algorithm is dependent on the available algorithms supported by OpenSSL - see createHash above.  key is the hmac key to be used."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createcipher_algorithm_password","title":"crypto.createCipher(algorithm, password)","description":"Creates and returns a cipher object, with the given algorithm and password.   algorithm is dependent on OpenSSL, examples are &#39;aes192&#39;, etc.  On recent releases, openssl list-cipher-algorithms will display the available cipher algorithms.  password is used to derive key and IV, which must be a &#39;binary&#39; encoded string or a buffer.   It is a stream that is both readable and writable.  The written data is used to compute the hash.  Once the writable side of the stream is ended, use the read() method to get the computed hash digest.  The legacy update and digest methods are also supported."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createcipheriv_algorithm_key_iv","title":"crypto.createCipheriv(algorithm, key, iv)","description":"Creates and returns a cipher object, with the given algorithm, key and iv.   algorithm is the same as the argument to createCipher().  key is the raw key used by the algorithm.  iv is an initialization vector.   key and iv must be &#39;binary&#39; encoded strings or buffers."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createdecipher_algorithm_password","title":"crypto.createDecipher(algorithm, password)","description":"Creates and returns a decipher object, with the given algorithm and key.  This is the mirror of the [createCipher()][] above."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createdecipheriv_algorithm_key_iv","title":"crypto.createDecipheriv(algorithm, key, iv)","description":"Creates and returns a decipher object, with the given algorithm, key and iv.  This is the mirror of the [createCipheriv()][] above."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createsign_algorithm","title":"crypto.createSign(algorithm)","description":"Creates and returns a signing object, with the given algorithm.  On recent OpenSSL releases, openssl list-public-key-algorithms will display the available signing algorithms. Examples are &#39;RSA-SHA256&#39;."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createverify_algorithm","title":"crypto.createVerify(algorithm)","description":"Creates and returns a verification object, with the given algorithm. This is the mirror of the signing object above."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_creatediffiehellman_prime_length","title":"crypto.createDiffieHellman(prime_length)","description":"Creates a Diffie-Hellman key exchange object and generates a prime of the given bit length. The generator used is 2."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_creatediffiehellman_prime_encoding","title":"crypto.createDiffieHellman(prime, [encoding])","description":"Creates a Diffie-Hellman key exchange object using the supplied prime. The generator used is 2. Encoding can be &#39;binary&#39;, &#39;hex&#39;, or &#39;base64&#39;.  If no encoding is specified, then a buffer is expected."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_getdiffiehellman_group_name","title":"crypto.getDiffieHellman(group_name)","description":"Creates a predefined Diffie-Hellman key exchange object.  The supported groups are: &#39;modp1&#39;, &#39;modp2&#39;, &#39;modp5&#39; (defined in [RFC 2412][]) and &#39;modp14&#39;, &#39;modp15&#39;, &#39;modp16&#39;, &#39;modp17&#39;, &#39;modp18&#39; (defined in [RFC 3526][]).  The returned object mimics the interface of objects created by [crypto.createDiffieHellman()][] above, but will not allow to change the keys (with [diffieHellman.setPublicKey()][] for example).  The advantage of using this routine is that the parties don&#39;t have to generate nor exchange group modulus beforehand, saving both processor and communication time.   Example (obtaining a shared secret):   var crypto = require(&#39;crypto&#39;); var alice = crypto.getDiffieHellman(&#39;modp5&#39;); var bob = crypto.getDiffieHellman(&#39;modp5&#39;);  alice.generateKeys(); bob.generateKeys();  var alice_secret = alice.computeSecret(bob.getPublicKey(), null, &#39;hex&#39;); var bob_secret = bob.computeSecret(alice.getPublicKey(), null, &#39;hex&#39;);  \/* alice_secret and bob_secret should be the same *\/ console.log(alice_secret == bob_secret);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_pbkdf2_password_salt_iterations_keylen_callback","title":"crypto.pbkdf2(password, salt, iterations, keylen, callback)","description":"Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive a key of given length from the given password, salt and iterations. The callback gets two arguments (err, derivedKey)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_pbkdf2sync_password_salt_iterations_keylen","title":"crypto.pbkdf2Sync(password, salt, iterations, keylen)","description":"Synchronous PBKDF2 function.  Returns derivedKey or throws error."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_randombytes_size_callback","title":"crypto.randomBytes(size, [callback])","description":"Generates cryptographically strong pseudo-random data. Usage:   \/\/ async crypto.randomBytes(256, function(ex, buf) {   if (ex) throw ex;   console.log(&#39;Have %d bytes of random data: %s&#39;, buf.length, buf); });  \/\/ sync try {   var buf = crypto.randomBytes(256);   console.log(&#39;Have %d bytes of random data: %s&#39;, buf.length, buf); } catch (ex) {   \/\/ handle error }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_pseudorandombytes_size_callback","title":"crypto.pseudoRandomBytes(size, [callback])","description":"Generates non-cryptographically strong pseudo-random data. The data returned will be unique if it is sufficiently long, but is not necessarily unpredictable. For this reason, the output of this function should never be used where unpredictability is important, such as in the generation of encryption keys.   Usage is otherwise identical to crypto.randomBytes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_recent_api_changes","title":"Recent API Changes","description":"The Crypto module was added to Node before there was the concept of a unified Stream API, and before there were Buffer objects for handling binary data.   As such, the streaming classes don&#39;t have the typical methods found on other Node classes, and many methods accepted and returned Binary-encoded strings by default rather than Buffers.  This was changed to use Buffers by default instead.   This is a breaking change for some use cases, but not all.   For example, if you currently use the default arguments to the Sign class, and then pass the results to the Verify class, without ever inspecting the data, then it will continue to work as before.  Where you once got a binary string and then presented the binary string to the Verify object, you&#39;ll now get a Buffer, and present the Buffer to the Verify object.   However, if you were doing things with the string data that will not work properly on Buffers (such as, concatenating them, storing in databases, etc.), or you are passing binary strings to the crypto functions without an encoding argument, then you will need to start providing encoding arguments to specify which encoding you&#39;d like to use.  To switch to the previous style of using binary strings by default, set the crypto.DEFAULT_ENCODING field to &#39;binary&#39;.  Note that new programs will probably expect buffers, so only use this as a temporary measure."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_ssl","title":"TLS (SSL)","description":"Use require(&#39;tls&#39;) to access this module.   The tls module uses OpenSSL to provide Transport Layer Security and\/or Secure Socket Layer: encrypted stream communication.   TLS\/SSL is a public\/private key infrastructure. Each client and each server must have a private key. A private key is created like this   openssl genrsa -out ryans-key.pem 1024 All severs and some clients need to have a certificate. Certificates are public keys signed by a Certificate Authority or self-signed. The first step to getting a certificate is to create a \"Certificate Signing Request\" (CSR) file. This is done with:   openssl req -new -key ryans-key.pem -out ryans-csr.pem To create a self-signed certificate with the CSR, do this:   openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem Alternatively you can send the CSR to a Certificate Authority for signing.   (TODO: docs on creating a CA, for now interested users should just look at test\/fixtures\/keys\/Makefile in the Node source code)   To create .pfx or .p12, do this:   openssl pkcs12 -export -in agent5-cert.pem -inkey agent5-key.pem \\     -certfile ca-cert.pem -out agent5.pfx  in:  certificate inkey: private key certfile: all CA certs concatenated in one file like cat ca1-cert.pem ca2-cert.pem > ca-cert.pem"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_createserver_options_secureconnectionlistener","title":"tls.createServer(options, [secureConnectionListener])","description":"Creates a new [tls.Server][].  The connectionListener argument is automatically set as a listener for the [secureConnection][] event.  The options object has these possibilities:    pfx: A string or Buffer containing the private key, certificate and CA certs of the server in PFX or PKCS12 format. (Mutually exclusive with the key, cert and ca options.)  key: A string or Buffer containing the private key of the server in PEM format. (Required)  passphrase: A string of passphrase for the private key or pfx.  cert: A string or Buffer containing the certificate key of the server in PEM format. (Required)  ca: An array of strings or Buffers of trusted certificates. If this is omitted several well known \"root\" CAs will be used, like VeriSign. These are used to authorize connections.  crl : Either a string or list of strings of PEM encoded CRLs (Certificate Revocation List)  ciphers: A string describing the ciphers to use or exclude. To mitigate [BEAST attacks] it is recommended that you use this option in conjunction with the honorCipherOrder option described below to prioritize the non-CBC cipher. Defaults to ECDHE-RSA-AES128-SHA256:AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH. Consult the [OpenSSL cipher list format documentation] for details on the format. ECDHE-RSA-AES128-SHA256 and AES128-GCM-SHA256 are used when node.js is linked against OpenSSL 1.0.1 or newer and the client speaks TLS 1.2, RC4 is used as a secure fallback. NOTE: Previous revisions of this section suggested AES256-SHA as an acceptable cipher. Unfortunately, AES256-SHA is a CBC cipher and therefore susceptible to BEAST attacks. Do not use it.  handshakeTimeout: Abort the connection if the SSL\/TLS handshake does not finish in this many milliseconds. The default is 120 seconds. A &#39;clientError&#39; is emitted on the tls.Server object whenever a handshake times out.  honorCipherOrder : When choosing a cipher, use the server&#39;s preferences instead of the client preferences. Note that if SSLv2 is used, the server will send its list of preferences to the client, and the client chooses the cipher. Although, this option is disabled by default, it is recommended that you use this option in conjunction with the ciphers option to mitigate BEAST attacks.  requestCert: If true the server will request a certificate from clients that connect and attempt to verify that certificate. Default: false.  rejectUnauthorized: If true the server will reject any connection which is not authorized with the list of supplied CAs. This option only has an effect if requestCert is true. Default: false.  NPNProtocols: An array or Buffer of possible NPN protocols. (Protocols should be ordered by their priority).  SNICallback: A function that will be called if client supports SNI TLS extension. Only one argument will be passed to it: servername. And SNICallback should return SecureContext instance. (You can use crypto.createCredentials(...).context to get proper SecureContext). If SNICallback wasn&#39;t provided - default callback with high-level API will be used (see below).  sessionIdContext: A string containing a opaque identifier for session resumption. If requestCert is true, the default is MD5 hash value generated from command-line. Otherwise, the default is not provided.   Here is a simple example echo server:   var tls = require(&#39;tls&#39;); var fs = require(&#39;fs&#39;);  var options = {   key: fs.readFileSync(&#39;server-key.pem&#39;),   cert: fs.readFileSync(&#39;server-cert.pem&#39;),    \/\/ This is necessary only if using the client certificate authentication.   requestCert: true,    \/\/ This is necessary only if the client uses the self-signed certificate.   ca: [ fs.readFileSync(&#39;client-cert.pem&#39;) ] };  var server = tls.createServer(options, function(cleartextStream) {   console.log(&#39;server connected&#39;,               cleartextStream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);   cleartextStream.write(\"welcome!\\n\");   cleartextStream.setEncoding(&#39;utf8&#39;);   cleartextStream.pipe(cleartextStream); }); server.listen(8000, function() {   console.log(&#39;server bound&#39;); }); Or   var tls = require(&#39;tls&#39;); var fs = require(&#39;fs&#39;);  var options = {   pfx: fs.readFileSync(&#39;server.pfx&#39;),    \/\/ This is necessary only if using the client certificate authentication.   requestCert: true,  };  var server = tls.createServer(options, function(cleartextStream) {   console.log(&#39;server connected&#39;,               cleartextStream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);   cleartextStream.write(\"welcome!\\n\");   cleartextStream.setEncoding(&#39;utf8&#39;);   cleartextStream.pipe(cleartextStream); }); server.listen(8000, function() {   console.log(&#39;server bound&#39;); }); You can test this server by connecting to it with openssl s_client:    openssl s_client -connect 127.0.0.1:8000"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_connect_options_callback","title":"tls.connect(options, [callback])","description":"Creates a new client connection to the given port and host (old API) or options.port and options.host. (If host is omitted, it defaults to localhost.) options should be an object which specifies:    host: Host the client should connect to  port: Port the client should connect to  socket: Establish secure connection on a given socket rather than creating a new socket. If this option is specified, host and port are ignored.  pfx: A string or Buffer containing the private key, certificate and CA certs of the server in PFX or PKCS12 format.  key: A string or Buffer containing the private key of the client in PEM format.  passphrase: A string of passphrase for the private key or pfx.  cert: A string or Buffer containing the certificate key of the client in PEM format.  ca: An array of strings or Buffers of trusted certificates. If this is omitted several well known \"root\" CAs will be used, like VeriSign. These are used to authorize connections.  rejectUnauthorized: If true, the server certificate is verified against the list of supplied CAs. An &#39;error&#39; event is emitted if verification fails. Default: true.  NPNProtocols: An array of string or Buffer containing supported NPN protocols. Buffer should have following format: 0x05hello0x05world, where first byte is next protocol name&#39;s length. (Passing array should usually be much simpler: [&#39;hello&#39;, &#39;world&#39;].)  servername: Servername for SNI (Server Name Indication) TLS extension.   The callback parameter will be added as a listener for the [&#39;secureConnect&#39;][] event.   tls.connect() returns a [CleartextStream][] object.   Here is an example of a client of echo server as described previously:   var tls = require(&#39;tls&#39;); var fs = require(&#39;fs&#39;);  var options = {   \/\/ These are necessary only if using the client certificate authentication   key: fs.readFileSync(&#39;client-key.pem&#39;),   cert: fs.readFileSync(&#39;client-cert.pem&#39;),    \/\/ This is necessary only if the server uses the self-signed certificate   ca: [ fs.readFileSync(&#39;server-cert.pem&#39;) ] };  var cleartextStream = tls.connect(8000, options, function() {   console.log(&#39;client connected&#39;,               cleartextStream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);   process.stdin.pipe(cleartextStream);   process.stdin.resume(); }); cleartextStream.setEncoding(&#39;utf8&#39;); cleartextStream.on(&#39;data&#39;, function(data) {   console.log(data); }); cleartextStream.on(&#39;end&#39;, function() {   server.close(); }); Or   var tls = require(&#39;tls&#39;); var fs = require(&#39;fs&#39;);  var options = {   pfx: fs.readFileSync(&#39;client.pfx&#39;) };  var cleartextStream = tls.connect(8000, options, function() {   console.log(&#39;client connected&#39;,               cleartextStream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);   process.stdin.pipe(cleartextStream);   process.stdin.resume(); }); cleartextStream.setEncoding(&#39;utf8&#39;); cleartextStream.on(&#39;data&#39;, function(data) {   console.log(data); }); cleartextStream.on(&#39;end&#39;, function() {   server.close(); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_connect_port_host_options_callback","title":"tls.connect(port, [host], [options], [callback])","description":"Creates a new client connection to the given port and host (old API) or options.port and options.host. (If host is omitted, it defaults to localhost.) options should be an object which specifies:    host: Host the client should connect to  port: Port the client should connect to  socket: Establish secure connection on a given socket rather than creating a new socket. If this option is specified, host and port are ignored.  pfx: A string or Buffer containing the private key, certificate and CA certs of the server in PFX or PKCS12 format.  key: A string or Buffer containing the private key of the client in PEM format.  passphrase: A string of passphrase for the private key or pfx.  cert: A string or Buffer containing the certificate key of the client in PEM format.  ca: An array of strings or Buffers of trusted certificates. If this is omitted several well known \"root\" CAs will be used, like VeriSign. These are used to authorize connections.  rejectUnauthorized: If true, the server certificate is verified against the list of supplied CAs. An &#39;error&#39; event is emitted if verification fails. Default: true.  NPNProtocols: An array of string or Buffer containing supported NPN protocols. Buffer should have following format: 0x05hello0x05world, where first byte is next protocol name&#39;s length. (Passing array should usually be much simpler: [&#39;hello&#39;, &#39;world&#39;].)  servername: Servername for SNI (Server Name Indication) TLS extension.   The callback parameter will be added as a listener for the [&#39;secureConnect&#39;][] event.   tls.connect() returns a [CleartextStream][] object.   Here is an example of a client of echo server as described previously:   var tls = require(&#39;tls&#39;); var fs = require(&#39;fs&#39;);  var options = {   \/\/ These are necessary only if using the client certificate authentication   key: fs.readFileSync(&#39;client-key.pem&#39;),   cert: fs.readFileSync(&#39;client-cert.pem&#39;),    \/\/ This is necessary only if the server uses the self-signed certificate   ca: [ fs.readFileSync(&#39;server-cert.pem&#39;) ] };  var cleartextStream = tls.connect(8000, options, function() {   console.log(&#39;client connected&#39;,               cleartextStream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);   process.stdin.pipe(cleartextStream);   process.stdin.resume(); }); cleartextStream.setEncoding(&#39;utf8&#39;); cleartextStream.on(&#39;data&#39;, function(data) {   console.log(data); }); cleartextStream.on(&#39;end&#39;, function() {   server.close(); }); Or   var tls = require(&#39;tls&#39;); var fs = require(&#39;fs&#39;);  var options = {   pfx: fs.readFileSync(&#39;client.pfx&#39;) };  var cleartextStream = tls.connect(8000, options, function() {   console.log(&#39;client connected&#39;,               cleartextStream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);   process.stdin.pipe(cleartextStream);   process.stdin.resume(); }); cleartextStream.setEncoding(&#39;utf8&#39;); cleartextStream.on(&#39;data&#39;, function(data) {   console.log(data); }); cleartextStream.on(&#39;end&#39;, function() {   server.close(); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized","title":"tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])","description":"Creates a new secure pair object with two streams, one of which reads\/writes encrypted data, and one reads\/writes cleartext data. Generally the encrypted one is piped to\/from an incoming encrypted data stream, and the cleartext one is used as a replacement for the initial encrypted stream.    credentials: A credentials object from crypto.createCredentials( ... )  isServer: A boolean indicating whether this tls connection should be opened as a server or a client.  requestCert: A boolean indicating whether a server should request a certificate from a connecting client. Only applies to server connections.  rejectUnauthorized: A boolean indicating whether a server should automatically reject clients with invalid certificates. Only applies to servers with requestCert enabled.   tls.createSecurePair() returns a SecurePair object with [cleartext][] and encrypted stream properties."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_client_initiated_renegotiation_attack_mitigation","title":"Client-initiated renegotiation attack mitigation","description":"The TLS protocol lets the client renegotiate certain aspects of the TLS session. Unfortunately, session renegotiation requires a disproportional amount of server-side resources, which makes it a potential vector for denial-of-service attacks.   To mitigate this, renegotiations are limited to three times every 10 minutes. An error is emitted on the [CleartextStream][] instance when the threshold is exceeded. The limits are configurable:    tls.CLIENT_RENEG_LIMIT: renegotiation limit, default is 3.  tls.CLIENT_RENEG_WINDOW: renegotiation window in seconds, default is                        10 minutes.   Don&#39;t change the defaults unless you know what you are doing.   To test your server, connect to it with openssl s_client -connect address:port and tap R<CR> (that&#39;s the letter R followed by a carriage return) a few times."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_npn_and_sni","title":"NPN and SNI","description":"NPN (Next Protocol Negotiation) and SNI (Server Name Indication) are TLS handshake extensions allowing you:    NPN - to use one TLS server for multiple protocols (HTTP, SPDY) SNI - to use one TLS server for multiple hostnames with different SSL certificates."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stringdecoder","title":"StringDecoder","description":"To use this module, do require(&#39;string_decoder&#39;). StringDecoder decodes a buffer to a string. It is a simple interface to buffer.toString() but provides additional support for utf8.   var StringDecoder = require(&#39;string_decoder&#39;).StringDecoder; var decoder = new StringDecoder(&#39;utf8&#39;);  var cent = new Buffer([0xC2, 0xA2]); console.log(decoder.write(cent));  var euro = new Buffer([0xE2, 0x82, 0xAC]); console.log(decoder.write(euro));"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_system","title":"File System","description":"File I\/O is provided by simple wrappers around standard POSIX functions.  To use this module do require(&#39;fs&#39;). All the methods have asynchronous and synchronous forms.   The asynchronous form always take a completion callback as its last argument. The arguments passed to the completion callback depend on the method, but the first argument is always reserved for an exception. If the operation was completed successfully, then the first argument will be null or undefined.   When using the synchronous form any exceptions are immediately thrown. You can use try\/catch to handle exceptions or allow them to bubble up.   Here is an example of the asynchronous version:   var fs = require(&#39;fs&#39;);  fs.unlink(&#39;\/tmp\/hello&#39;, function (err) {   if (err) throw err;   console.log(&#39;successfully deleted \/tmp\/hello&#39;); }); Here is the synchronous version:   var fs = require(&#39;fs&#39;);  fs.unlinkSync(&#39;\/tmp\/hello&#39;) console.log(&#39;successfully deleted \/tmp\/hello&#39;); With the asynchronous methods there is no guaranteed ordering. So the following is prone to error:   fs.rename(&#39;\/tmp\/hello&#39;, &#39;\/tmp\/world&#39;, function (err) {   if (err) throw err;   console.log(&#39;renamed complete&#39;); }); fs.stat(&#39;\/tmp\/world&#39;, function (err, stats) {   if (err) throw err;   console.log(&#39;stats: &#39; + JSON.stringify(stats)); }); It could be that fs.stat is executed before fs.rename. The correct way to do this is to chain the callbacks.   fs.rename(&#39;\/tmp\/hello&#39;, &#39;\/tmp\/world&#39;, function (err) {   if (err) throw err;   fs.stat(&#39;\/tmp\/world&#39;, function (err, stats) {     if (err) throw err;     console.log(&#39;stats: &#39; + JSON.stringify(stats));   }); }); In busy processes, the programmer is strongly encouraged to use the asynchronous versions of these calls. The synchronous versions will block the entire process until they complete--halting all connections.   Relative path to filename can be used, remember however that this path will be relative to process.cwd().   Most fs functions let you omit the callback argument. If you do, a default callback is used that ignores errors, but prints a deprecation warning.   IMPORTANT: Omitting the callback is deprecated.  v0.12 will throw the errors as exceptions."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_rename_oldpath_newpath_callback","title":"fs.rename(oldPath, newPath, callback)","description":"Asynchronous rename(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_renamesync_oldpath_newpath","title":"fs.renameSync(oldPath, newPath)","description":"Synchronous rename(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_ftruncate_fd_len_callback","title":"fs.ftruncate(fd, len, callback)","description":"Asynchronous ftruncate(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_ftruncatesync_fd_len","title":"fs.ftruncateSync(fd, len)","description":"Synchronous ftruncate(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_truncate_path_len_callback","title":"fs.truncate(path, len, callback)","description":"Asynchronous truncate(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_truncatesync_path_len","title":"fs.truncateSync(path, len)","description":"Synchronous truncate(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_chown_path_uid_gid_callback","title":"fs.chown(path, uid, gid, callback)","description":"Asynchronous chown(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_chownsync_path_uid_gid","title":"fs.chownSync(path, uid, gid)","description":"Synchronous chown(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fchown_fd_uid_gid_callback","title":"fs.fchown(fd, uid, gid, callback)","description":"Asynchronous fchown(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fchownsync_fd_uid_gid","title":"fs.fchownSync(fd, uid, gid)","description":"Synchronous fchown(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lchown_path_uid_gid_callback","title":"fs.lchown(path, uid, gid, callback)","description":"Asynchronous lchown(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lchownsync_path_uid_gid","title":"fs.lchownSync(path, uid, gid)","description":"Synchronous lchown(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_chmod_path_mode_callback","title":"fs.chmod(path, mode, callback)","description":"Asynchronous chmod(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_chmodsync_path_mode","title":"fs.chmodSync(path, mode)","description":"Synchronous chmod(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fchmod_fd_mode_callback","title":"fs.fchmod(fd, mode, callback)","description":"Asynchronous fchmod(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fchmodsync_fd_mode","title":"fs.fchmodSync(fd, mode)","description":"Synchronous fchmod(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lchmod_path_mode_callback","title":"fs.lchmod(path, mode, callback)","description":"Asynchronous lchmod(2). No arguments other than a possible exception are given to the completion callback.   Only available on Mac OS X."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lchmodsync_path_mode","title":"fs.lchmodSync(path, mode)","description":"Synchronous lchmod(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_stat_path_callback","title":"fs.stat(path, callback)","description":"Asynchronous stat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object.  See the fs.Stats section below for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lstat_path_callback","title":"fs.lstat(path, callback)","description":"Asynchronous lstat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object. lstat() is identical to stat(), except that if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fstat_fd_callback","title":"fs.fstat(fd, callback)","description":"Asynchronous fstat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object. fstat() is identical to stat(), except that the file to be stat-ed is specified by the file descriptor fd."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_statsync_path","title":"fs.statSync(path)","description":"Synchronous stat(2). Returns an instance of fs.Stats."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lstatsync_path","title":"fs.lstatSync(path)","description":"Synchronous lstat(2). Returns an instance of fs.Stats."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fstatsync_fd","title":"fs.fstatSync(fd)","description":"Synchronous fstat(2). Returns an instance of fs.Stats."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_link_srcpath_dstpath_callback","title":"fs.link(srcpath, dstpath, callback)","description":"Asynchronous link(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_linksync_srcpath_dstpath","title":"fs.linkSync(srcpath, dstpath)","description":"Synchronous link(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_symlink_srcpath_dstpath_type_callback","title":"fs.symlink(srcpath, dstpath, [type], callback)","description":"Asynchronous symlink(2). No arguments other than a possible exception are given to the completion callback. type argument can be either &#39;dir&#39;, &#39;file&#39;, or &#39;junction&#39; (default is &#39;file&#39;).  It is only  used on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute.  When using &#39;junction&#39;, the destination argument will automatically be normalized to absolute path."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_symlinksync_srcpath_dstpath_type","title":"fs.symlinkSync(srcpath, dstpath, [type])","description":"Synchronous symlink(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readlink_path_callback","title":"fs.readlink(path, callback)","description":"Asynchronous readlink(2). The callback gets two arguments (err, linkString)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readlinksync_path","title":"fs.readlinkSync(path)","description":"Synchronous readlink(2). Returns the symbolic link&#39;s string value."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_realpath_path_cache_callback","title":"fs.realpath(path, [cache], callback)","description":"Asynchronous realpath(2). The callback gets two arguments (err, resolvedPath). May use process.cwd to resolve relative paths. cache is an object literal of mapped paths that can be used to force a specific path resolution or avoid additional fs.stat calls for known real paths.   Example:   var cache = {&#39;\/etc&#39;:&#39;\/private\/etc&#39;}; fs.realpath(&#39;\/etc\/passwd&#39;, cache, function (err, resolvedPath) {   if (err) throw err;   console.log(resolvedPath); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_realpathsync_path_cache","title":"fs.realpathSync(path, [cache])","description":"Synchronous realpath(2). Returns the resolved path."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_unlink_path_callback","title":"fs.unlink(path, callback)","description":"Asynchronous unlink(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_unlinksync_path","title":"fs.unlinkSync(path)","description":"Synchronous unlink(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_rmdir_path_callback","title":"fs.rmdir(path, callback)","description":"Asynchronous rmdir(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_rmdirsync_path","title":"fs.rmdirSync(path)","description":"Synchronous rmdir(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_mkdir_path_mode_callback","title":"fs.mkdir(path, [mode], callback)","description":"Asynchronous mkdir(2). No arguments other than a possible exception are given to the completion callback. mode defaults to 0777."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_mkdirsync_path_mode","title":"fs.mkdirSync(path, [mode])","description":"Synchronous mkdir(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readdir_path_callback","title":"fs.readdir(path, callback)","description":"Asynchronous readdir(3).  Reads the contents of a directory. The callback gets two arguments (err, files) where files is an array of the names of the files in the directory excluding &#39;.&#39; and &#39;..&#39;."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readdirsync_path","title":"fs.readdirSync(path)","description":"Synchronous readdir(3). Returns an array of filenames excluding &#39;.&#39; and &#39;..&#39;."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_close_fd_callback","title":"fs.close(fd, callback)","description":"Asynchronous close(2).  No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_closesync_fd","title":"fs.closeSync(fd)","description":"Synchronous close(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_open_path_flags_mode_callback","title":"fs.open(path, flags, [mode], callback)","description":"Asynchronous file open. See open(2). flags can be:    &#39;r&#39; - Open file for reading. An exception occurs if the file does not exist.  &#39;r+&#39; - Open file for reading and writing. An exception occurs if the file does not exist.  &#39;rs&#39; - Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache. This is primarily useful for opening files on NFS mounts as it allows you to skip the potentially stale local cache. It has a very real impact on I\/O performance so don&#39;t use this mode unless you need it. Note that this doesn&#39;t turn fs.open() into a synchronous blocking call. If that&#39;s what you want then you should be using fs.openSync()  &#39;rs+&#39; - Open file for reading and writing, telling the OS to open it synchronously. See notes for &#39;rs&#39; about using this with caution.  &#39;w&#39; - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).  &#39;wx&#39; - Like &#39;w&#39; but opens the file in exclusive mode.  &#39;w+&#39; - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).  &#39;wx+&#39; - Like &#39;w+&#39; but opens the file in exclusive mode.  &#39;a&#39; - Open file for appending. The file is created if it does not exist.  &#39;ax&#39; - Like &#39;a&#39; but opens the file in exclusive mode.  &#39;a+&#39; - Open file for reading and appending. The file is created if it does not exist.  &#39;ax+&#39; - Like &#39;a+&#39; but opens the file in exclusive mode.   mode defaults to 0666. The callback gets two arguments (err, fd).   Exclusive mode (O_EXCL) ensures that path is newly created. fs.open() fails if a file by that name already exists. On POSIX systems, symlinks are not followed. Exclusive mode may or may not work with network file systems."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_opensync_path_flags_mode","title":"fs.openSync(path, flags, [mode])","description":"Synchronous open(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_utimes_path_atime_mtime_callback","title":"fs.utimes(path, atime, mtime, callback)","description":"Change file timestamps of the file referenced by the supplied path."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_utimessync_path_atime_mtime","title":"fs.utimesSync(path, atime, mtime)","description":"Change file timestamps of the file referenced by the supplied path."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_futimes_fd_atime_mtime_callback","title":"fs.futimes(fd, atime, mtime, callback)","description":"Change the file timestamps of a file referenced by the supplied file descriptor."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_futimessync_fd_atime_mtime","title":"fs.futimesSync(fd, atime, mtime)","description":"Change the file timestamps of a file referenced by the supplied file descriptor."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fsync_fd_callback","title":"fs.fsync(fd, callback)","description":"Asynchronous fsync(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fsyncsync_fd","title":"fs.fsyncSync(fd)","description":"Synchronous fsync(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_write_fd_buffer_offset_length_position_callback","title":"fs.write(fd, buffer, offset, length, position, callback)","description":"Write buffer to the file specified by fd.   offset and length determine the part of the buffer to be written.   position refers to the offset from the beginning of the file where this data should be written. If position is null, the data will be written at the current position. See pwrite(2).   The callback will be given three arguments (err, written, buffer) where written specifies how many bytes were written from buffer.   Note that it is unsafe to use fs.write multiple times on the same file without waiting for the callback. For this scenario, fs.createWriteStream is strongly recommended."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_writesync_fd_buffer_offset_length_position","title":"fs.writeSync(fd, buffer, offset, length, position)","description":"Synchronous version of fs.write(). Returns the number of bytes written."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_read_fd_buffer_offset_length_position_callback","title":"fs.read(fd, buffer, offset, length, position, callback)","description":"Read data from the file specified by fd.   buffer is the buffer that the data will be written to.   offset is offset within the buffer where reading will start.   length is an integer specifying the number of bytes to read.   position is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.   The callback is given the three arguments, (err, bytesRead, buffer)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readsync_fd_buffer_offset_length_position","title":"fs.readSync(fd, buffer, offset, length, position)","description":"Synchronous version of fs.read. Returns the number of bytesRead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readfile_filename_options_callback","title":"fs.readFile(filename, [options], callback)","description":"Asynchronously reads the entire contents of a file. Example:   fs.readFile(&#39;\/etc\/passwd&#39;, function (err, data) {   if (err) throw err;   console.log(data); }); The callback is passed two arguments (err, data), where data is the contents of the file.   If no encoding is specified, then the raw buffer is returned."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readfilesync_filename_options","title":"fs.readFileSync(filename, [options])","description":"Synchronous version of fs.readFile. Returns the contents of the filename.   If the encoding option is specified then this function returns a string. Otherwise it returns a buffer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_writefile_filename_data_options_callback","title":"fs.writeFile(filename, data, [options], callback)","description":"Asynchronously writes data to a file, replacing the file if it already exists. data can be a string or a buffer.   The encoding option is ignored if data is a buffer. It defaults to &#39;utf8&#39;.   Example:   fs.writeFile(&#39;message.txt&#39;, &#39;Hello Node&#39;, function (err) {   if (err) throw err;   console.log(&#39;It\\&#39;s saved!&#39;); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_writefilesync_filename_data_options","title":"fs.writeFileSync(filename, data, [options])","description":"The synchronous version of fs.writeFile."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_appendfile_filename_data_options_callback","title":"fs.appendFile(filename, data, [options], callback)","description":"Asynchronously append data to a file, creating the file if it not yet exists. data can be a string or a buffer.   Example:   fs.appendFile(&#39;message.txt&#39;, &#39;data to append&#39;, function (err) {   if (err) throw err;   console.log(&#39;The \"data to append\" was appended to file!&#39;); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_appendfilesync_filename_data_options","title":"fs.appendFileSync(filename, data, [options])","description":"The synchronous version of fs.appendFile."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_watchfile_filename_options_listener","title":"fs.watchFile(filename, [options], listener)","description":"Watch for changes on filename. The callback listener will be called each time the file is accessed.   The second argument is optional. The options if provided should be an object containing two members a boolean, persistent, and interval. persistent indicates whether the process should continue to run as long as files are being watched. interval indicates how often the target should be polled, in milliseconds. The default is { persistent: true, interval: 5007 }.   The listener gets two arguments the current stat object and the previous stat object:   fs.watchFile(&#39;message.text&#39;, function (curr, prev) {   console.log(&#39;the current mtime is: &#39; + curr.mtime);   console.log(&#39;the previous mtime was: &#39; + prev.mtime); }); These stat objects are instances of fs.Stat.   If you want to be notified when the file was modified, not just accessed you need to compare curr.mtime and prev.mtime."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_unwatchfile_filename_listener","title":"fs.unwatchFile(filename, [listener])","description":"Stop watching for changes on filename. If listener is specified, only that particular listener is removed. Otherwise, all listeners are removed and you have effectively stopped watching filename.   Calling fs.unwatchFile() with a filename that is not being watched is a no-op, not an error."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_watch_filename_options_listener","title":"fs.watch(filename, [options], [listener])","description":"Watch for changes on filename, where filename is either a file or a directory.  The returned object is a fs.FSWatcher.   The second argument is optional. The options if provided should be an object containing a boolean member persistent, which indicates whether the process should continue to run as long as files are being watched. The default is { persistent: true }.   The listener callback gets two arguments (event, filename).  event is either &#39;rename&#39; or &#39;change&#39;, and filename is the name of the file which triggered the event."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_caveats","title":"Caveats","description":"The fs.watch API is not 100% consistent across platforms, and is unavailable in some situations."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_availability","title":"Availability","description":"This feature depends on the underlying operating system providing a way to be notified of filesystem changes.    On Linux systems, this uses inotify. On BSD systems (including OS X), this uses kqueue. On SunOS systems (including Solaris and SmartOS), this uses event ports. On Windows systems, this feature depends on ReadDirectoryChangesW.  If the underlying functionality is not available for some reason, then fs.watch will not be able to function.  For example, watching files or directories on network file systems (NFS, SMB, etc.) often doesn&#39;t work reliably or at all.   You can still use fs.watchFile, which uses stat polling, but it is slower and less reliable."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_filename_argument","title":"Filename Argument","description":"Providing filename argument in the callback is not supported on every platform (currently it&#39;s only supported on Linux and Windows).  Even on supported platforms filename is not always guaranteed to be provided. Therefore, don&#39;t assume that filename argument is always provided in the callback, and have some fallback logic if it is null.   fs.watch(&#39;somedir&#39;, function (event, filename) {   console.log(&#39;event is: &#39; + event);   if (filename) {     console.log(&#39;filename provided: &#39; + filename);   } else {     console.log(&#39;filename not provided&#39;);   } });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_exists_path_callback","title":"fs.exists(path, callback)","description":"Test whether or not the given path exists by checking with the file system. Then call the callback argument with either true or false.  Example:   fs.exists(&#39;\/etc\/passwd&#39;, function (exists) {   util.debug(exists ? \"it&#39;s there\" : \"no passwd!\"); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_existssync_path","title":"fs.existsSync(path)","description":"Synchronous version of fs.exists."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_createreadstream_path_options","title":"fs.createReadStream(path, [options])","description":"Returns a new ReadStream object (See Readable Stream).   options is an object with the following defaults:   { flags: &#39;r&#39;,   encoding: null,   fd: null,   mode: 0666,   bufferSize: 64 * 1024,   autoClose: true } options can include start and end values to read a range of bytes from the file instead of the entire file.  Both start and end are inclusive and start at 0. The encoding can be &#39;utf8&#39;, &#39;ascii&#39;, or &#39;base64&#39;.   If autoClose is false, then the file descriptor won&#39;t be closed, even if there&#39;s an error.  It is your responsiblity to close it and make sure there&#39;s no file descriptor leak.  If autoClose is set to true (default behavior), on error or end the file descriptor will be closed automatically.   An example to read the last 10 bytes of a file which is 100 bytes long:   fs.createReadStream(&#39;sample.txt&#39;, {start: 90, end: 99});"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_createwritestream_path_options","title":"fs.createWriteStream(path, [options])","description":"Returns a new WriteStream object (See Writable Stream).   options is an object with the following defaults:   { flags: &#39;w&#39;,   encoding: null,   mode: 0666 } options may also include a start option to allow writing data at some position past the beginning of the file.  Modifying a file rather than replacing it may require a flags mode of r+ rather than the default mode w."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path","title":"Path","description":"This module contains utilities for handling and transforming file paths.  Almost all these methods perform only string transformations. The file system is not consulted to check whether paths are valid.   Use require(&#39;path&#39;) to use this module.  The following methods are provided:"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_normalize_p","title":"path.normalize(p)","description":"Normalize a string path, taking care of &#39;..&#39; and &#39;.&#39; parts.   When multiple slashes are found, they&#39;re replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.   Example:   path.normalize(&#39;\/foo\/bar\/\/baz\/asdf\/quux\/..&#39;) \/\/ returns &#39;\/foo\/bar\/baz\/asdf&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_join_path1_path2","title":"path.join([path1], [path2], [...])","description":"Join all arguments together and normalize the resulting path.   Arguments must be strings.  In v0.8, non-string arguments were silently ignored.  In v0.10 and up, an exception is thrown.   Example:   path.join(&#39;\/foo&#39;, &#39;bar&#39;, &#39;baz\/asdf&#39;, &#39;quux&#39;, &#39;..&#39;) \/\/ returns &#39;\/foo\/bar\/baz\/asdf&#39;  path.join(&#39;foo&#39;, {}, &#39;bar&#39;) \/\/ returns &#39;foo\/bar&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_resolve_from_to","title":"path.resolve([from ...], to)","description":"Resolves to to an absolute path.   If to isn&#39;t already absolute from arguments are prepended in right to left order, until an absolute path is found. If after using all from paths still no absolute path is found, the current working directory is used as well. The resulting path is normalized, and trailing slashes are removed unless the path gets resolved to the root directory. Non-string arguments are ignored.   Another way to think of it is as a sequence of cd commands in a shell.   path.resolve(&#39;foo\/bar&#39;, &#39;\/tmp\/file\/&#39;, &#39;..&#39;, &#39;a\/..\/subfile&#39;) Is similar to:   cd foo\/bar cd \/tmp\/file\/ cd .. cd a\/..\/subfile pwd The difference is that the different paths don&#39;t need to exist and may also be files.   Examples:   path.resolve(&#39;\/foo\/bar&#39;, &#39;.\/baz&#39;) \/\/ returns &#39;\/foo\/bar\/baz&#39;  path.resolve(&#39;\/foo\/bar&#39;, &#39;\/tmp\/file\/&#39;) \/\/ returns &#39;\/tmp\/file&#39;  path.resolve(&#39;wwwroot&#39;, &#39;static_files\/png\/&#39;, &#39;..\/gif\/image.gif&#39;) \/\/ if currently in \/home\/myself\/node, it returns &#39;\/home\/myself\/node\/wwwroot\/static_files\/gif\/image.gif&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_relative_from_to","title":"path.relative(from, to)","description":"Solve the relative path from from to to.   At times we have two absolute paths, and we need to derive the relative path from one to the other.  This is actually the reverse transform of path.resolve, which means we see that:   path.resolve(from, path.relative(from, to)) == path.resolve(to) Examples:   path.relative(&#39;C:\\\\orandea\\\\test\\\\aaa&#39;, &#39;C:\\\\orandea\\\\impl\\\\bbb&#39;) \/\/ returns &#39;..\\\\..\\\\impl\\\\bbb&#39;  path.relative(&#39;\/data\/orandea\/test\/aaa&#39;, &#39;\/data\/orandea\/impl\/bbb&#39;) \/\/ returns &#39;..\/..\/impl\/bbb&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_dirname_p","title":"path.dirname(p)","description":"Return the directory name of a path.  Similar to the Unix dirname command.   Example:   path.dirname(&#39;\/foo\/bar\/baz\/asdf\/quux&#39;) \/\/ returns &#39;\/foo\/bar\/baz\/asdf&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_basename_p_ext","title":"path.basename(p, [ext])","description":"Return the last portion of a path.  Similar to the Unix basename command.   Example:   path.basename(&#39;\/foo\/bar\/baz\/asdf\/quux.html&#39;) \/\/ returns &#39;quux.html&#39;  path.basename(&#39;\/foo\/bar\/baz\/asdf\/quux.html&#39;, &#39;.html&#39;) \/\/ returns &#39;quux&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_extname_p","title":"path.extname(p)","description":"Return the extension of the path, from the last &#39;.&#39; to end of string in the last portion of the path.  If there is no &#39;.&#39; in the last portion of the path or the first character of it is &#39;.&#39;, then it returns an empty string.  Examples:   path.extname(&#39;index.html&#39;) \/\/ returns &#39;.html&#39;  path.extname(&#39;index.&#39;) \/\/ returns &#39;.&#39;  path.extname(&#39;index&#39;) \/\/ returns &#39;&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net","title":"net","description":"The net module provides you with an asynchronous network wrapper. It contains methods for creating both servers and clients (called streams). You can include this module with require(&#39;net&#39;);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_createserver_options_connectionlistener","title":"net.createServer([options], [connectionListener])","description":"Creates a new TCP server. The connectionListener argument is automatically set as a listener for the [&#39;connection&#39;][] event.   options is an object with the following defaults:   { allowHalfOpen: false } If allowHalfOpen is true, then the socket won&#39;t automatically send a FIN packet when the other end of the socket sends a FIN packet. The socket becomes non-readable, but still writable. You should call the end() method explicitly. See [&#39;end&#39;][] event for more information.   Here is an example of an echo server which listens for connections on port 8124:   var net = require(&#39;net&#39;); var server = net.createServer(function(c) { \/\/&#39;connection&#39; listener   console.log(&#39;server connected&#39;);   c.on(&#39;end&#39;, function() {     console.log(&#39;server disconnected&#39;);   });   c.write(&#39;hello\\r\\n&#39;);   c.pipe(c); }); server.listen(8124, function() { \/\/&#39;listening&#39; listener   console.log(&#39;server bound&#39;); }); Test this by using telnet:   telnet localhost 8124 To listen on the socket \/tmp\/echo.sock the third line from the last would just be changed to   server.listen(&#39;\/tmp\/echo.sock&#39;, function() { \/\/&#39;listening&#39; listener Use nc to connect to a UNIX domain socket server:   nc -U \/tmp\/echo.sock"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_connect_options_connectionlistener","title":"net.connect(options, [connectionListener])","description":"Constructs a new socket object and opens the socket to the given location. When the socket is established, the [&#39;connect&#39;][] event will be emitted.   For TCP sockets, options argument should be an object which specifies:    port: Port the client should connect to (Required).  host: Host the client should connect to. Defaults to &#39;localhost&#39;.  localAddress: Local interface to bind to for network connections.   For UNIX domain sockets, options argument should be an object which specifies:    path: Path the client should connect to (Required).  Common options are:    allowHalfOpen: if true, the socket won&#39;t automatically send a FIN packet when the other end of the socket sends a FIN packet. Defaults to false.  See [&#39;end&#39;][] event for more information.  The connectListener parameter will be added as an listener for the [&#39;connect&#39;][] event.   Here is an example of a client of echo server as described previously:   var net = require(&#39;net&#39;); var client = net.connect({port: 8124},     function() { \/\/&#39;connect&#39; listener   console.log(&#39;client connected&#39;);   client.write(&#39;world!\\r\\n&#39;); }); client.on(&#39;data&#39;, function(data) {   console.log(data.toString());   client.end(); }); client.on(&#39;end&#39;, function() {   console.log(&#39;client disconnected&#39;); }); To connect on the socket \/tmp\/echo.sock the second line would just be changed to   var client = net.connect({path: &#39;\/tmp\/echo.sock&#39;},"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_createconnection_options_connectionlistener","title":"net.createConnection(options, [connectionListener])","description":"Constructs a new socket object and opens the socket to the given location. When the socket is established, the [&#39;connect&#39;][] event will be emitted.   For TCP sockets, options argument should be an object which specifies:    port: Port the client should connect to (Required).  host: Host the client should connect to. Defaults to &#39;localhost&#39;.  localAddress: Local interface to bind to for network connections.   For UNIX domain sockets, options argument should be an object which specifies:    path: Path the client should connect to (Required).  Common options are:    allowHalfOpen: if true, the socket won&#39;t automatically send a FIN packet when the other end of the socket sends a FIN packet. Defaults to false.  See [&#39;end&#39;][] event for more information.  The connectListener parameter will be added as an listener for the [&#39;connect&#39;][] event.   Here is an example of a client of echo server as described previously:   var net = require(&#39;net&#39;); var client = net.connect({port: 8124},     function() { \/\/&#39;connect&#39; listener   console.log(&#39;client connected&#39;);   client.write(&#39;world!\\r\\n&#39;); }); client.on(&#39;data&#39;, function(data) {   console.log(data.toString());   client.end(); }); client.on(&#39;end&#39;, function() {   console.log(&#39;client disconnected&#39;); }); To connect on the socket \/tmp\/echo.sock the second line would just be changed to   var client = net.connect({path: &#39;\/tmp\/echo.sock&#39;},"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_connect_port_host_connectlistener","title":"net.connect(port, [host], [connectListener])","description":"Creates a TCP connection to port on host. If host is omitted, &#39;localhost&#39; will be assumed. The connectListener parameter will be added as an listener for the [&#39;connect&#39;][] event."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_createconnection_port_host_connectlistener","title":"net.createConnection(port, [host], [connectListener])","description":"Creates a TCP connection to port on host. If host is omitted, &#39;localhost&#39; will be assumed. The connectListener parameter will be added as an listener for the [&#39;connect&#39;][] event."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_connect_path_connectlistener","title":"net.connect(path, [connectListener])","description":"Creates unix socket connection to path. The connectListener parameter will be added as an listener for the [&#39;connect&#39;][] event."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_createconnection_path_connectlistener","title":"net.createConnection(path, [connectListener])","description":"Creates unix socket connection to path. The connectListener parameter will be added as an listener for the [&#39;connect&#39;][] event."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_isip_input","title":"net.isIP(input)","description":"Tests if input is an IP address. Returns 0 for invalid strings, returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_isipv4_input","title":"net.isIPv4(input)","description":"Returns true if input is a version 4 IP address, otherwise returns false."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_isipv6_input","title":"net.isIPv6(input)","description":"Returns true if input is a version 6 IP address, otherwise returns false."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_udp_datagram_sockets","title":"UDP \/ Datagram Sockets","description":"Datagram sockets are available through require(&#39;dgram&#39;).   Important note: the behavior of dgram.Socket#bind() has changed in v0.10 and is always asynchronous now.  If you have code that looks like this:   var s = dgram.createSocket(&#39;udp4&#39;); s.bind(1234); s.addMembership(&#39;224.0.0.114&#39;); You have to change it to this:   var s = dgram.createSocket(&#39;udp4&#39;); s.bind(1234, function() {   s.addMembership(&#39;224.0.0.114&#39;); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dgram_createsocket_type_callback","title":"dgram.createSocket(type, [callback])","description":"Creates a datagram Socket of the specified types.  Valid types are udp4 and udp6.   Takes an optional callback which is added as a listener for message events.   Call socket.bind if you want to receive datagrams. socket.bind() will bind to the \"all interfaces\" address on a random port (it does the right thing for both udp4 and udp6 sockets). You can then retrieve the address and port with socket.address().address and socket.address().port."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns","title":"DNS","description":"Use require(&#39;dns&#39;) to access this module. All methods in the dns module use C-Ares except for dns.lookup which uses getaddrinfo(3) in a thread pool. C-Ares is much faster than getaddrinfo but the system resolver is more constant with how other programs operate. When a user does net.connect(80, &#39;google.com&#39;) or http.get({ host: &#39;google.com&#39; }) the dns.lookup method is used. Users who need to do a large number of look ups quickly should use the methods that go through C-Ares.   Here is an example which resolves &#39;www.google.com&#39; then reverse resolves the IP addresses which are returned.   var dns = require(&#39;dns&#39;);  dns.resolve4(&#39;www.google.com&#39;, function (err, addresses) {   if (err) throw err;    console.log(&#39;addresses: &#39; + JSON.stringify(addresses));    addresses.forEach(function (a) {     dns.reverse(a, function (err, domains) {       if (err) {         throw err;       }        console.log(&#39;reverse for &#39; + a + &#39;: &#39; + JSON.stringify(domains));     });   }); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_lookup_domain_family_callback","title":"dns.lookup(domain, [family], callback)","description":"Resolves a domain (e.g. &#39;google.com&#39;) into the first found A (IPv4) or AAAA (IPv6) record. The family can be the integer 4 or 6. Defaults to null that indicates both Ip v4 and v6 address family.   The callback has arguments (err, address, family).  The address argument is a string representation of a IP v4 or v6 address. The family argument is either the integer 4 or 6 and denotes the family of address (not necessarily the value initially passed to lookup).   On error, err is an Error object, where err.code is the error code. Keep in mind that err.code will be set to &#39;ENOENT&#39; not only when the domain does not exist but also when the lookup fails in other ways such as no available file descriptors."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolve_domain_rrtype_callback","title":"dns.resolve(domain, [rrtype], callback)","description":"Resolves a domain (e.g. &#39;google.com&#39;) into an array of the record types specified by rrtype. Valid rrtypes are &#39;A&#39; (IPV4 addresses, default), &#39;AAAA&#39; (IPV6 addresses), &#39;MX&#39; (mail exchange records), &#39;TXT&#39; (text records), &#39;SRV&#39; (SRV records), &#39;PTR&#39; (used for reverse IP lookups), &#39;NS&#39; (name server records) and &#39;CNAME&#39; (canonical name records).   The callback has arguments (err, addresses).  The type of each item in addresses is determined by the record type, and described in the documentation for the corresponding lookup methods below.   On error, err is an Error object, where err.code is one of the error codes listed below."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolve4_domain_callback","title":"dns.resolve4(domain, callback)","description":"The same as dns.resolve(), but only for IPv4 queries (A records). addresses is an array of IPv4 addresses (e.g. [&#39;74.125.79.104&#39;, &#39;74.125.79.105&#39;, &#39;74.125.79.106&#39;])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolve6_domain_callback","title":"dns.resolve6(domain, callback)","description":"The same as dns.resolve4() except for IPv6 queries (an AAAA query)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvemx_domain_callback","title":"dns.resolveMx(domain, callback)","description":"The same as dns.resolve(), but only for mail exchange queries (MX records).   addresses is an array of MX records, each with a priority and an exchange attribute (e.g. [{&#39;priority&#39;: 10, &#39;exchange&#39;: &#39;mx.example.com&#39;},...])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvetxt_domain_callback","title":"dns.resolveTxt(domain, callback)","description":"The same as dns.resolve(), but only for text queries (TXT records). addresses is an array of the text records available for domain (e.g., [&#39;v=spf1 ip4:0.0.0.0 ~all&#39;])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvesrv_domain_callback","title":"dns.resolveSrv(domain, callback)","description":"The same as dns.resolve(), but only for service records (SRV records). addresses is an array of the SRV records available for domain. Properties of SRV records are priority, weight, port, and name (e.g., [{&#39;priority&#39;: 10, {&#39;weight&#39;: 5, &#39;port&#39;: 21223, &#39;name&#39;: &#39;service.example.com&#39;}, ...])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvens_domain_callback","title":"dns.resolveNs(domain, callback)","description":"The same as dns.resolve(), but only for name server records (NS records). addresses is an array of the name server records available for domain (e.g., [&#39;ns1.example.com&#39;, &#39;ns2.example.com&#39;])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvecname_domain_callback","title":"dns.resolveCname(domain, callback)","description":"The same as dns.resolve(), but only for canonical name records (CNAME records). addresses is an array of the canonical name records available for domain (e.g., [&#39;bar.example.com&#39;])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_reverse_ip_callback","title":"dns.reverse(ip, callback)","description":"Reverse resolves an ip address to an array of domain names.   The callback has arguments (err, domains).   On error, err is an Error object, where err.code is one of the error codes listed below."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_error_codes","title":"Error codes","description":"Each DNS query can return one of the following error codes:    dns.NODATA: DNS server returned answer with no data. dns.FORMERR: DNS server claims query was misformatted. dns.SERVFAIL: DNS server returned general failure. dns.NOTFOUND: Domain name not found. dns.NOTIMP: DNS server does not implement requested operation. dns.REFUSED: DNS server refused query. dns.BADQUERY: Misformatted DNS query. dns.BADNAME: Misformatted domain name. dns.BADFAMILY: Unsupported address family. dns.BADRESP: Misformatted DNS reply. dns.CONNREFUSED: Could not contact DNS servers. dns.TIMEOUT: Timeout while contacting DNS servers. dns.EOF: End of file. dns.FILE: Error reading file. dns.NOMEM: Out of memory. dns.DESTRUCTION: Channel is being destroyed. dns.BADSTR: Misformatted string. dns.BADFLAGS: Illegal flags specified. dns.NONAME: Given hostname is not numeric. dns.BADHINTS: Illegal hints flags specified. dns.NOTINITIALIZED: c-ares library initialization not yet performed. dns.LOADIPHLPAPI: Error loading iphlpapi.dll. dns.ADDRGETNETWORKPARAMS: Could not find GetNetworkParams function. dns.CANCELLED: DNS query cancelled."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http","title":"HTTP","description":"To use the HTTP server and client one must require(&#39;http&#39;).   The HTTP interfaces in Node are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses--the user is able to stream data.   HTTP message headers are represented by an object like this:   { &#39;content-length&#39;: &#39;123&#39;,   &#39;content-type&#39;: &#39;text\/plain&#39;,   &#39;connection&#39;: &#39;keep-alive&#39;,   &#39;accept&#39;: &#39;*\/*&#39; } Keys are lowercased. Values are not modified.   In order to support the full spectrum of possible HTTP applications, Node&#39;s HTTP API is very low-level. It deals with stream handling and message parsing only. It parses a message into headers and body but it does not parse the actual headers or the body."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http_createserver_requestlistener","title":"http.createServer([requestListener])","description":"Returns a new web server object.   The requestListener is a function which is automatically added to the &#39;request&#39; event."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http_createclient_port_host","title":"http.createClient([port], [host])","description":"This function is deprecated; please use [http.request()][] instead. Constructs a new HTTP client. port and host refer to the server to be connected to."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http_request_options_callback","title":"http.request(options, callback)","description":"Node maintains several connections per server to make HTTP requests. This function allows one to transparently issue requests.   options can be an object or a string. If options is a string, it is automatically parsed with [url.parse()][].   Options:    host: A domain name or IP address of the server to issue the request to. Defaults to &#39;localhost&#39;. hostname: To support url.parse() hostname is preferred over host port: Port of remote server. Defaults to 80. localAddress: Local interface to bind for network connections. socketPath: Unix Domain Socket (use one of host:port or socketPath) method: A string specifying the HTTP request method. Defaults to &#39;GET&#39;. path: Request path. Defaults to &#39;\/&#39;. Should include query string if any. E.G. &#39;\/index.html?page=12&#39; headers: An object containing request headers. auth: Basic authentication i.e. &#39;user:password&#39; to compute an Authorization header. agent: Controls [Agent][] behavior. When an Agent is used request will default to Connection: keep-alive. Possible values: undefined (default): use [global Agent][] for this host and port. Agent object: explicitly use the passed in Agent. false: opts out of connection pooling with an Agent, defaults request to Connection: close.    http.request() returns an instance of the http.ClientRequest class. The ClientRequest instance is a writable stream. If one needs to upload a file with a POST request, then write to the ClientRequest object.   Example:   var options = {   hostname: &#39;www.google.com&#39;,   port: 80,   path: &#39;\/upload&#39;,   method: &#39;POST&#39; };  var req = http.request(options, function(res) {   console.log(&#39;STATUS: &#39; + res.statusCode);   console.log(&#39;HEADERS: &#39; + JSON.stringify(res.headers));   res.setEncoding(&#39;utf8&#39;);   res.on(&#39;data&#39;, function (chunk) {     console.log(&#39;BODY: &#39; + chunk);   }); });  req.on(&#39;error&#39;, function(e) {   console.log(&#39;problem with request: &#39; + e.message); });  \/\/ write data to request body req.write(&#39;data\\n&#39;); req.write(&#39;data\\n&#39;); req.end(); Note that in the example req.end() was called. With http.request() one must always call req.end() to signify that you&#39;re done with the request - even if there is no data being written to the request body.   If any error is encountered during the request (be that with DNS resolution, TCP level errors, or actual HTTP parse errors) an &#39;error&#39; event is emitted on the returned request object.   There are a few special headers that should be noted.    Sending a &#39;Connection: keep-alive&#39; will notify Node that the connection to the server should be persisted until the next request.  Sending a &#39;Content-length&#39; header will disable the default chunked encoding.  Sending an &#39;Expect&#39; header will immediately send the request headers. Usually, when sending &#39;Expect: 100-continue&#39;, you should both set a timeout and listen for the continue event. See RFC2616 Section 8.2.3 for more information.  Sending an Authorization header will override using the auth option to compute basic authentication."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http_get_options_callback","title":"http.get(options, callback)","description":"Since most requests are GET requests without bodies, Node provides this convenience method. The only difference between this method and http.request() is that it sets the method to GET and calls req.end() automatically.   Example:   http.get(\"http:\/\/www.google.com\/index.html\", function(res) {   console.log(\"Got response: \" + res.statusCode); }).on(&#39;error&#39;, function(e) {   console.log(\"Got error: \" + e.message); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_https","title":"HTTPS","description":"HTTPS is the HTTP protocol over TLS\/SSL. In Node this is implemented as a separate module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_https_createserver_options_requestlistener","title":"https.createServer(options, [requestListener])","description":"Returns a new HTTPS web server object. The options is similar to [tls.createServer()][].  The requestListener is a function which is automatically added to the &#39;request&#39; event.   Example:   \/\/ curl -k https:\/\/localhost:8000\/ var https = require(&#39;https&#39;); var fs = require(&#39;fs&#39;);  var options = {   key: fs.readFileSync(&#39;test\/fixtures\/keys\/agent2-key.pem&#39;),   cert: fs.readFileSync(&#39;test\/fixtures\/keys\/agent2-cert.pem&#39;) };  https.createServer(options, function (req, res) {   res.writeHead(200);   res.end(\"hello world\\n\"); }).listen(8000); Or   var https = require(&#39;https&#39;); var fs = require(&#39;fs&#39;);  var options = {   pfx: fs.readFileSync(&#39;server.pfx&#39;) };  https.createServer(options, function (req, res) {   res.writeHead(200);   res.end(\"hello world\\n\"); }).listen(8000);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_server_listen_path_callback","title":"server.listen(path, [callback])","description":"See [http.listen()][] for details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_server_listen_handle_callback","title":"server.listen(handle, [callback])","description":"See [http.listen()][] for details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_server_close_callback","title":"server.close([callback])","description":"See [http.close()][] for details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_https_request_options_callback","title":"https.request(options, callback)","description":"Makes a request to a secure web server.   options can be an object or a string. If options is a string, it is automatically parsed with url.parse().   All options from [http.request()][] are valid.   Example:   var https = require(&#39;https&#39;);  var options = {   hostname: &#39;encrypted.google.com&#39;,   port: 443,   path: &#39;\/&#39;,   method: &#39;GET&#39; };  var req = https.request(options, function(res) {   console.log(\"statusCode: \", res.statusCode);   console.log(\"headers: \", res.headers);    res.on(&#39;data&#39;, function(d) {     process.stdout.write(d);   }); }); req.end();  req.on(&#39;error&#39;, function(e) {   console.error(e); }); The options argument has the following options    host: A domain name or IP address of the server to issue the request to. Defaults to &#39;localhost&#39;. hostname: To support url.parse() hostname is preferred over host port: Port of remote server. Defaults to 443. method: A string specifying the HTTP request method. Defaults to &#39;GET&#39;. path: Request path. Defaults to &#39;\/&#39;. Should include query string if any. E.G. &#39;\/index.html?page=12&#39; headers: An object containing request headers. auth: Basic authentication i.e. &#39;user:password&#39; to compute an Authorization header. agent: Controls [Agent][] behavior. When an Agent is used request will default to Connection: keep-alive. Possible values: undefined (default): use [globalAgent][] for this host and port. Agent object: explicitly use the passed in Agent. false: opts out of connection pooling with an Agent, defaults request to Connection: close.    The following options from [tls.connect()][] can also be specified. However, a [globalAgent][] silently ignores these.    pfx: Certificate, Private key and CA certificates to use for SSL. Default null. key: Private key to use for SSL. Default null. passphrase: A string of passphrase for the private key or pfx. Default null. cert: Public x509 certificate to use. Default null. ca: An authority certificate or array of authority certificates to check the remote host against. ciphers: A string describing the ciphers to use or exclude. Consult http:\/\/www.openssl.org\/docs\/apps\/ciphers.html#CIPHER_LIST_FORMAT for details on the format. rejectUnauthorized: If true, the server certificate is verified against the list of supplied CAs. An &#39;error&#39; event is emitted if verification fails. Verification happens at the connection level, before the HTTP request is sent. Default true.  In order to specify these options, use a custom Agent.   Example:   var options = {   hostname: &#39;encrypted.google.com&#39;,   port: 443,   path: &#39;\/&#39;,   method: &#39;GET&#39;,   key: fs.readFileSync(&#39;test\/fixtures\/keys\/agent2-key.pem&#39;),   cert: fs.readFileSync(&#39;test\/fixtures\/keys\/agent2-cert.pem&#39;) }; options.agent = new https.Agent(options);  var req = https.request(options, function(res) {   ... } Or does not use an Agent.   Example:   var options = {   hostname: &#39;encrypted.google.com&#39;,   port: 443,   path: &#39;\/&#39;,   method: &#39;GET&#39;,   key: fs.readFileSync(&#39;test\/fixtures\/keys\/agent2-key.pem&#39;),   cert: fs.readFileSync(&#39;test\/fixtures\/keys\/agent2-cert.pem&#39;),   agent: false };  var req = https.request(options, function(res) {   ... }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_https_get_options_callback","title":"https.get(options, callback)","description":"Like http.get() but for HTTPS.   options can be an object or a string. If options is a string, it is automatically parsed with url.parse().   Example:   var https = require(&#39;https&#39;);  https.get(&#39;https:\/\/encrypted.google.com\/&#39;, function(res) {   console.log(\"statusCode: \", res.statusCode);   console.log(\"headers: \", res.headers);    res.on(&#39;data&#39;, function(d) {     process.stdout.write(d);   });  }).on(&#39;error&#39;, function(e) {   console.error(e); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url","title":"URL","description":"This module has utilities for URL resolution and parsing. Call require(&#39;url&#39;) to use it.   Parsed URL objects have some or all of the following fields, depending on whether or not they exist in the URL string. Any parts that are not in the URL string will not be in the parsed object. Examples are shown for the URL   &#39;http:\/\/user:pass@host.com:8080\/p\/a\/t\/h?query=string#hash&#39;    href: The full URL that was originally parsed. Both the protocol and host are lowercased.   Example: &#39;http:\/\/user:pass@host.com:8080\/p\/a\/t\/h?query=string#hash&#39;  protocol: The request protocol, lowercased.   Example: &#39;http:&#39;  host: The full lowercased host portion of the URL, including port information.   Example: &#39;host.com:8080&#39;  auth: The authentication information portion of a URL.   Example: &#39;user:pass&#39;  hostname: Just the lowercased hostname portion of the host.   Example: &#39;host.com&#39;  port: The port number portion of the host.   Example: &#39;8080&#39;  pathname: The path section of the URL, that comes after the host and before the query, including the initial slash if present.   Example: &#39;\/p\/a\/t\/h&#39;  search: The &#39;query string&#39; portion of the URL, including the leading question mark.   Example: &#39;?query=string&#39;  path: Concatenation of pathname and search.   Example: &#39;\/p\/a\/t\/h?query=string&#39;  query: Either the &#39;params&#39; portion of the query string, or a querystring-parsed object.   Example: &#39;query=string&#39; or {&#39;query&#39;:&#39;string&#39;}  hash: The &#39;fragment&#39; portion of the URL including the pound-sign.   Example: &#39;#hash&#39;   The following methods are provided by the URL module:"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_parse_urlstr_parsequerystring_slashesdenotehost","title":"url.parse(urlStr, [parseQueryString], [slashesDenoteHost])","description":"Take a URL string, and return an object.   Pass true as the second argument to also parse the query string using the querystring module. Defaults to false.   Pass true as the third argument to treat \/\/foo\/bar as { host: &#39;foo&#39;, pathname: &#39;\/bar&#39; } rather than { pathname: &#39;\/\/foo\/bar&#39; }. Defaults to false."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_format_urlobj","title":"url.format(urlObj)","description":"Take a parsed URL object, and return a formatted URL string.    href will be ignored. protocolis treated the same with or without the trailing : (colon). The protocols http, https, ftp, gopher, file will be postfixed with :\/\/ (colon-slash-slash). All other protocols mailto, xmpp, aim, sftp, foo, etc will be postfixed with : (colon)   auth will be used if present. hostname will only be used if host is absent. port will only be used if host is absent. host will be used in place of hostname and port pathname is treated the same with or without the leading \/ (slash) search will be used in place of query query (object; see querystring) will only be used if search is absent. search is treated the same with or without the leading ? (question mark) hash is treated the same with or without the leading # (pound sign, anchor)"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_resolve_from_to","title":"url.resolve(from, to)","description":"Take a base URL, and a href URL, and resolve them as a browser would for an anchor tag.  Examples:   url.resolve(&#39;\/one\/two\/three&#39;, &#39;four&#39;)         \/\/ &#39;\/one\/two\/four&#39; url.resolve(&#39;http:\/\/example.com\/&#39;, &#39;\/one&#39;)    \/\/ &#39;http:\/\/example.com\/one&#39; url.resolve(&#39;http:\/\/example.com\/one&#39;, &#39;\/two&#39;) \/\/ &#39;http:\/\/example.com\/two&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_query_string","title":"Query String","description":"This module provides utilities for dealing with query strings. It provides the following methods:"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_querystring_stringify_obj_sep_eq","title":"querystring.stringify(obj, [sep], [eq])","description":"Serialize an object to a query string. Optionally override the default separator (&#39;&&#39;) and assignment (&#39;=&#39;) characters.   Example:   querystring.stringify({ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; }) \/\/ returns &#39;foo=bar&baz=qux&baz=quux&corge=&#39;  querystring.stringify({foo: &#39;bar&#39;, baz: &#39;qux&#39;}, &#39;;&#39;, &#39;:&#39;) \/\/ returns &#39;foo:bar;baz:qux&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_querystring_parse_str_sep_eq_options","title":"querystring.parse(str, [sep], [eq], [options])","description":"Deserialize a query string to an object. Optionally override the default separator (&#39;&&#39;) and assignment (&#39;=&#39;) characters.   Options object may contain maxKeys property (equal to 1000 by default), it&#39;ll be used to limit processed keys. Set it to 0 to remove key count limitation.   Example:   querystring.parse(&#39;foo=bar&baz=qux&baz=quux&corge&#39;) \/\/ returns { foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_punycode","title":"punycode","description":"Punycode.js is bundled with Node.js v0.6.2+. Use require(&#39;punycode&#39;) to access it. (To use it with other Node.js versions, use npm to install the punycode module first.)"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_punycode_decode_string","title":"punycode.decode(string)","description":"Converts a Punycode string of ASCII code points to a string of Unicode code points.   \/\/ decode domain name parts punycode.decode(&#39;maana-pta&#39;); \/\/ &#39;ma\u00f1ana&#39; punycode.decode(&#39;--dqo34k&#39;); \/\/ &#39;\u2603-\u2318&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_punycode_encode_string","title":"punycode.encode(string)","description":"Converts a string of Unicode code points to a Punycode string of ASCII code points.   \/\/ encode domain name parts punycode.encode(&#39;ma\u00f1ana&#39;); \/\/ &#39;maana-pta&#39; punycode.encode(&#39;\u2603-\u2318&#39;); \/\/ &#39;--dqo34k&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_punycode_tounicode_domain","title":"punycode.toUnicode(domain)","description":"Converts a Punycode string representing a domain name to Unicode. Only the Punycoded parts of the domain name will be converted, i.e. it doesn&#39;t matter if you call it on a string that has already been converted to Unicode.   \/\/ decode domain names punycode.toUnicode(&#39;xn--maana-pta.com&#39;); \/\/ &#39;ma\u00f1ana.com&#39; punycode.toUnicode(&#39;xn----dqo34k.com&#39;); \/\/ &#39;\u2603-\u2318.com&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_punycode_toascii_domain","title":"punycode.toASCII(domain)","description":"Converts a Unicode string representing a domain name to Punycode. Only the non-ASCII parts of the domain name will be converted, i.e. it doesn&#39;t matter if you call it with a domain that&#39;s already in ASCII.   \/\/ encode domain names punycode.toASCII(&#39;ma\u00f1ana.com&#39;); \/\/ &#39;xn--maana-pta.com&#39; punycode.toASCII(&#39;\u2603-\u2318.com&#39;); \/\/ &#39;xn----dqo34k.com&#39;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readline","title":"Readline","description":"To use this module, do require(&#39;readline&#39;). Readline allows reading of a stream (such as process.stdin) on a line-by-line basis.   Note that once you&#39;ve invoked this module, your node program will not terminate until you&#39;ve closed the interface. Here&#39;s how to allow your program to gracefully exit:   var readline = require(&#39;readline&#39;);  var rl = readline.createInterface({   input: process.stdin,   output: process.stdout });  rl.question(\"What do you think of node.js? \", function(answer) {   \/\/ TODO: Log the answer in a database   console.log(\"Thank you for your valuable feedback:\", answer);    rl.close(); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readline_createinterface_options","title":"readline.createInterface(options)","description":"Creates a readline Interface instance. Accepts an \"options\" Object that takes the following values:    input - the readable stream to listen to (Required).  output - the writable stream to write readline data to (Required).  completer - an optional function that is used for Tab autocompletion. See below for an example of using this.  terminal - pass true if the input and output streams should be treated like a TTY, and have ANSI\/VT100 escape codes written to it. Defaults to checking isTTY on the output stream upon instantiation.   The completer function is given a the current line entered by the user, and is supposed to return an Array with 2 entries:    An Array with matching entries for the completion.  The substring that was used for the matching.   Which ends up looking something like: [[substr1, substr2, ...], originalsubstring].   Example:   function completer(line) {   var completions = &#39;.help .error .exit .quit .q&#39;.split(&#39; &#39;)   var hits = completions.filter(function(c) { return c.indexOf(line) == 0 })   \/\/ show all completions if none found   return [hits.length ? hits : completions, line] } Also completer can be run in async mode if it accepts two arguments:   function completer(linePartial, callback) {   callback(null, [[&#39;123&#39;], linePartial]); } createInterface is commonly used with process.stdin and process.stdout in order to accept user input:   var readline = require(&#39;readline&#39;); var rl = readline.createInterface({   input: process.stdin,   output: process.stdout }); Once you have a readline instance, you most commonly listen for the \"line\" event.   If terminal is true for this instance then the output stream will get the best compatibility if it defines an output.columns property, and fires a \"resize\" event on the output if\/when the columns ever change (process.stdout does this automatically when it is a TTY)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_events","title":"Events","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_repl","title":"REPL","description":"A Read-Eval-Print-Loop (REPL) is available both as a standalone program and easily includable in other programs. The REPL provides a way to interactively run JavaScript and see the results.  It can be used for debugging, testing, or just trying things out.   By executing node without any arguments from the command-line you will be dropped into the REPL. It has simplistic emacs line-editing.   mjr:~$ node Type &#39;.help&#39; for options. > a = [ 1, 2, 3]; [ 1, 2, 3 ] > a.forEach(function (v) { ...   console.log(v); ...   }); 1 2 3 For advanced line-editors, start node with the environmental variable NODE_NO_READLINE=1. This will start the main and debugger REPL in canonical terminal settings which will allow you to use with rlwrap.   For example, you could add this to your bashrc file:   alias node=\"env NODE_NO_READLINE=1 rlwrap node\""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_repl_start_options","title":"repl.start(options)","description":"Returns and starts a REPLServer instance. Accepts an \"options\" Object that takes the following values:    prompt - the prompt and stream for all I\/O. Defaults to > .  input - the readable stream to listen to. Defaults to process.stdin.  output - the writable stream to write readline data to. Defaults to process.stdout.  terminal - pass true if the stream should be treated like a TTY, and have ANSI\/VT100 escape codes written to it. Defaults to checking isTTY on the output stream upon instantiation.  eval - function that will be used to eval each given line. Defaults to an async wrapper for eval(). See below for an example of a custom eval.  useColors - a boolean which specifies whether or not the writer function should output colors. If a different writer function is set then this does nothing. Defaults to the repl&#39;s terminal value.  useGlobal - if set to true, then the repl will use the global object, instead of running scripts in a separate context. Defaults to false.  ignoreUndefined - if set to true, then the repl will not output the return value of command if it&#39;s undefined. Defaults to false.  writer - the function to invoke for each command that gets evaluated which returns the formatting (including coloring) to display. Defaults to util.inspect.   You can use your own eval function if it has following signature:   function eval(cmd, context, filename, callback) {   callback(null, result); } Multiple REPLs may be started against the same running instance of node.  Each will share the same global object but will have unique I\/O.   Here is an example that starts a REPL on stdin, a Unix socket, and a TCP socket:   var net = require(\"net\"),     repl = require(\"repl\");  connections = 0;  repl.start({   prompt: \"node via stdin> \",   input: process.stdin,   output: process.stdout });  net.createServer(function (socket) {   connections += 1;   repl.start({     prompt: \"node via Unix socket> \",     input: socket,     output: socket   }).on(&#39;exit&#39;, function() {     socket.end();   }) }).listen(\"\/tmp\/node-repl-sock\");  net.createServer(function (socket) {   connections += 1;   repl.start({     prompt: \"node via TCP socket> \",     input: socket,     output: socket   }).on(&#39;exit&#39;, function() {     socket.end();   }); }).listen(5001); Running this program from the command line will start a REPL on stdin.  Other REPL clients may connect through the Unix socket or TCP socket. telnet is useful for connecting to TCP sockets, and socat can be used to connect to both Unix and TCP sockets.   By starting a REPL from a Unix socket-based server instead of stdin, you can connect to a long-running node process without restarting it.   For an example of running a \"full-featured\" (terminal) REPL over a net.Server and net.Socket instance, see: https:\/\/gist.github.com\/2209310   For an example of running a REPL instance over curl(1), see: https:\/\/gist.github.com\/2053342"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_repl_features","title":"REPL Features","description":"Inside the REPL, Control+D will exit.  Multi-line expressions can be input. Tab completion is supported for both global and local variables.   The special variable _ (underscore) contains the result of the last expression.   > [ \"a\", \"b\", \"c\" ] [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ] > _.length 3 > _ += 1 4 The REPL provides access to any variables in the global scope. You can expose a variable to the REPL explicitly by assigning it to the context object associated with each REPLServer.  For example:   \/\/ repl_test.js var repl = require(\"repl\"),     msg = \"message\";  repl.start(\"> \").context.m = msg; Things in the context object appear as local within the REPL:   mjr:~$ node repl_test.js > m &#39;message&#39; There are a few special REPL commands:    .break - While inputting a multi-line expression, sometimes you get lost or just don&#39;t care about completing it. .break will start over. .clear - Resets the context object to an empty object and clears any multi-line expression. .exit - Close the I\/O stream, which will cause the REPL to exit. .help - Show this list of special commands. .save - Save the current REPL session to a file .save .\/file\/to\/save.js   .load - Load a file into the current REPL session. .load .\/file\/to\/load.js    The following key combinations in the REPL have these special effects:    <ctrl>C - Similar to the .break keyword.  Terminates the current command.  Press twice on a blank line to forcibly exit. <ctrl>D - Similar to the .exit keyword."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_executing_javascript","title":"Executing JavaScript","description":"You can access this module with:   var vm = require(&#39;vm&#39;); JavaScript code can be compiled and run immediately or compiled, saved, and run later."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_runinthiscontext_code_filename","title":"vm.runInThisContext(code, [filename])","description":"vm.runInThisContext() compiles code, runs it and returns the result. Running code does not have access to local scope. filename is optional, it&#39;s used only in stack traces.   Example of using vm.runInThisContext and eval to run the same code:   var localVar = 123,     usingscript, evaled,     vm = require(&#39;vm&#39;);  usingscript = vm.runInThisContext(&#39;localVar = 1;&#39;,   &#39;myfile.vm&#39;); console.log(&#39;localVar: &#39; + localVar + &#39;, usingscript: &#39; +   usingscript); evaled = eval(&#39;localVar = 1;&#39;); console.log(&#39;localVar: &#39; + localVar + &#39;, evaled: &#39; +   evaled);  \/\/ localVar: 123, usingscript: 1 \/\/ localVar: 1, evaled: 1 vm.runInThisContext does not have access to the local scope, so localVar is unchanged. eval does have access to the local scope, so localVar is changed.   In case of syntax error in code, vm.runInThisContext emits the syntax error to stderr and throws an exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_runinnewcontext_code_sandbox_filename","title":"vm.runInNewContext(code, [sandbox], [filename])","description":"vm.runInNewContext compiles code, then runs it in sandbox and returns the result. Running code does not have access to local scope. The object sandbox will be used as the global object for code. sandbox and filename are optional, filename is only used in stack traces.   Example: compile and execute code that increments a global variable and sets a new one. These globals are contained in the sandbox.   var util = require(&#39;util&#39;),     vm = require(&#39;vm&#39;),     sandbox = {       animal: &#39;cat&#39;,       count: 2     };  vm.runInNewContext(&#39;count += 1; name = \"kitty\"&#39;, sandbox, &#39;myfile.vm&#39;); console.log(util.inspect(sandbox));  \/\/ { animal: &#39;cat&#39;, count: 3, name: &#39;kitty&#39; } Note that running untrusted code is a tricky business requiring great care.  To prevent accidental global variable leakage, vm.runInNewContext is quite useful, but safely running untrusted code requires a separate process.   In case of syntax error in code, vm.runInNewContext emits the syntax error to stderr and throws an exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_runincontext_code_context_filename","title":"vm.runInContext(code, context, [filename])","description":"vm.runInContext compiles code, then runs it in context and returns the result. A (V8) context comprises a global object, together with a set of built-in objects and functions. Running code does not have access to local scope and the global object held within context will be used as the global object for code. filename is optional, it&#39;s used only in stack traces.   Example: compile and execute code in a existing context.   var util = require(&#39;util&#39;),     vm = require(&#39;vm&#39;),     initSandbox = {       animal: &#39;cat&#39;,       count: 2     },     context = vm.createContext(initSandbox);  vm.runInContext(&#39;count += 1; name = \"CATT\"&#39;, context, &#39;myfile.vm&#39;); console.log(util.inspect(context));  \/\/ { animal: &#39;cat&#39;, count: 3, name: &#39;CATT&#39; } Note that createContext will perform a shallow clone of the supplied sandbox object in order to initialize the global object of the freshly constructed context.   Note that running untrusted code is a tricky business requiring great care.  To prevent accidental global variable leakage, vm.runInContext is quite useful, but safely running untrusted code requires a separate process.   In case of syntax error in code, vm.runInContext emits the syntax error to stderr and throws an exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_createcontext_initsandbox","title":"vm.createContext([initSandbox])","description":"vm.createContext creates a new context which is suitable for use as the 2nd argument of a subsequent call to vm.runInContext. A (V8) context comprises a global object together with a set of build-in objects and functions. The optional argument initSandbox will be shallow-copied to seed the initial contents of the global object used by the context."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_createscript_code_filename","title":"vm.createScript(code, [filename])","description":"createScript compiles code but does not run it. Instead, it returns a vm.Script object representing this compiled code. This script can be run later many times using methods below. The returned script is not bound to any global object. It is bound before each run, just for that run. filename is optional, it&#39;s only used in stack traces.   In case of syntax error in code, createScript prints the syntax error to stderr and throws an exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_caveats","title":"Caveats","description":"The vm module has many known issues and edge cases. If you run into issues or unexpected behavior, please consult the open issues on GitHub. Some of the biggest problems are described below."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_sandboxes","title":"Sandboxes","description":"The sandbox argument to vm.runInNewContext and vm.createContext, along with the initSandbox argument to vm.createContext, do not behave as one might normally expect and their behavior varies between different versions of Node.   The key issue to be aware of is that V8 provides no way to directly control the global object used within a context. As a result, while properties of your sandbox object will be available in the context, any properties from the prototypes of the sandbox may not be available. Furthermore, the this expression within the global scope of the context evaluates to the empty object ({}) instead of to your sandbox.   Your sandbox&#39;s properties are also not shared directly with the script. Instead, the properties of the sandbox are copied into the context at the beginning of execution, and then after execution, the properties are copied back out in an attempt to propagate any changes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_globals","title":"Globals","description":"Properties of the global object, like Array and String, have different values inside of a context. This means that common expressions like [] instanceof Array or Object.getPrototypeOf([]) === Array.prototype may not produce expected results when used inside of scripts evaluated via the vm module.   Some of these problems have known workarounds listed in the issues for vm on GitHub. for example, Array.isArray works around the example problem with Array."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process","title":"Child Process","description":"Node provides a tri-directional popen(3) facility through the child_process module.   It is possible to stream data through a child&#39;s stdin, stdout, and stderr in a fully non-blocking way.  (Note that some programs use line-buffered I\/O internally.  That doesn&#39;t affect node.js but it means data you send to the child process is not immediately consumed.)   To create a child process use require(&#39;child_process&#39;).spawn() or require(&#39;child_process&#39;).fork().  The semantics of each are slightly different, and explained below."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process_spawn_command_args_options","title":"child_process.spawn(command, [args], [options])","description":"Launches a new process with the given command, with  command line arguments in args. If omitted, args defaults to an empty Array.   The third argument is used to specify additional options, which defaults to:   { cwd: undefined,   env: process.env } cwd allows you to specify the working directory from which the process is spawned. Use env to specify environment variables that will be visible to the new process.   Example of running ls -lh \/usr, capturing stdout, stderr, and the exit code:   var spawn = require(&#39;child_process&#39;).spawn,     ls    = spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;\/usr&#39;]);  ls.stdout.on(&#39;data&#39;, function (data) {   console.log(&#39;stdout: &#39; + data); });  ls.stderr.on(&#39;data&#39;, function (data) {   console.log(&#39;stderr: &#39; + data); });  ls.on(&#39;close&#39;, function (code) {   console.log(&#39;child process exited with code &#39; + code); }); Example: A very elaborate way to run &#39;ps ax | grep ssh&#39;   var spawn = require(&#39;child_process&#39;).spawn,     ps    = spawn(&#39;ps&#39;, [&#39;ax&#39;]),     grep  = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);  ps.stdout.on(&#39;data&#39;, function (data) {   grep.stdin.write(data); });  ps.stderr.on(&#39;data&#39;, function (data) {   console.log(&#39;ps stderr: &#39; + data); });  ps.on(&#39;close&#39;, function (code) {   if (code !== 0) {     console.log(&#39;ps process exited with code &#39; + code);   }   grep.stdin.end(); });  grep.stdout.on(&#39;data&#39;, function (data) {   console.log(&#39;&#39; + data); });  grep.stderr.on(&#39;data&#39;, function (data) {   console.log(&#39;grep stderr: &#39; + data); });  grep.on(&#39;close&#39;, function (code) {   if (code !== 0) {     console.log(&#39;grep process exited with code &#39; + code);   } }); Example of checking for failed exec:   var spawn = require(&#39;child_process&#39;).spawn,     child = spawn(&#39;bad_command&#39;);  child.stderr.setEncoding(&#39;utf8&#39;); child.stderr.on(&#39;data&#39;, function (data) {   if (\/^execvp\\(\\)\/.test(data)) {     console.log(&#39;Failed to start child process.&#39;);   } }); Note that if spawn receives an empty options object, it will result in spawning the process with an empty environment rather than using process.env. This due to backwards compatibility issues with a deprecated API.   The &#39;stdio&#39; option to child_process.spawn() is an array where each index corresponds to a fd in the child.  The value is one of the following:    &#39;pipe&#39; - Create a pipe between the child process and the parent process. The parent end of the pipe is exposed to the parent as a property on the child_process object as ChildProcess.stdio[fd]. Pipes created for fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout and ChildProcess.stderr, respectively. &#39;ipc&#39; - Create an IPC channel for passing messages\/file descriptors between parent and child. A ChildProcess may have at most one IPC stdio file descriptor. Setting this option enables the ChildProcess.send() method. If the child writes JSON messages to this file descriptor, then this will trigger ChildProcess.on(&#39;message&#39;).  If the child is a Node.js program, then the presence of an IPC channel will enable process.send() and process.on(&#39;message&#39;). &#39;ignore&#39; - Do not set this file descriptor in the child. Note that Node will always open fd 0 - 2 for the processes it spawns. When any of these is ignored node will open \/dev\/null and attach it to the child&#39;s fd. Stream object - Share a readable or writable stream that refers to a tty, file, socket, or a pipe with the child process. The stream&#39;s underlying file descriptor is duplicated in the child process to the fd that  corresponds to the index in the stdio array. Positive integer - The integer value is interpreted as a file descriptor  that is is currently open in the parent process. It is shared with the child process, similar to how Stream objects can be shared. null, undefined - Use default value. For stdio fds 0, 1 and 2 (in other words, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the default is &#39;ignore&#39;.  As a shorthand, the stdio argument may also be one of the following strings, rather than an array:    ignore - [&#39;ignore&#39;, &#39;ignore&#39;, &#39;ignore&#39;] pipe - [&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;] inherit - [process.stdin, process.stdout, process.stderr] or [0,1,2]  Example:   var spawn = require(&#39;child_process&#39;).spawn;  \/\/ Child will use parent&#39;s stdios spawn(&#39;prg&#39;, [], { stdio: &#39;inherit&#39; });  \/\/ Spawn child sharing only stderr spawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, &#39;pipe&#39;, process.stderr] });  \/\/ Open an extra fd=4, to interact with programs present a \/\/ startd-style interface. spawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, null, null, null, &#39;pipe&#39;] }); If the detached option is set, the child process will be made the leader of a new process group.  This makes it possible for the child to continue running  after the parent exits.   By default, the parent will wait for the detached child to exit.  To prevent the parent from waiting for a given child, use the child.unref() method, and the parent&#39;s event loop will not include the child in its reference count.   Example of detaching a long-running process and redirecting its output to a file:    var fs = require(&#39;fs&#39;),      spawn = require(&#39;child_process&#39;).spawn,      out = fs.openSync(&#39;.\/out.log&#39;, &#39;a&#39;),      err = fs.openSync(&#39;.\/out.log&#39;, &#39;a&#39;);   var child = spawn(&#39;prg&#39;, [], {    detached: true,    stdio: [ &#39;ignore&#39;, out, err ]  });   child.unref(); When using the detached option to start a long-running process, the process will not stay running in the background unless it is provided with a stdio configuration that is not connected to the parent.  If the parent&#39;s stdio is inherited, the child will remain attached to the controlling terminal.   There is a deprecated option called customFds which allows one to specify specific file descriptors for the stdio of the child process. This API was not portable to all platforms and therefore removed. With customFds it was possible to hook up the new process&#39; [stdin, stdout, stderr] to existing streams; -1 meant that a new stream should be created. Use at your own risk.   There are several internal options. In particular stdinStream, stdoutStream, stderrStream. They are for INTERNAL USE ONLY. As with all undocumented APIs in Node, they should not be used.   See also: child_process.exec() and child_process.fork()"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process_exec_command_options_callback","title":"child_process.exec(command, [options], callback)","description":"Runs a command in a shell and buffers the output.   var exec = require(&#39;child_process&#39;).exec,     child;  child = exec(&#39;cat *.js bad_file | wc -l&#39;,   function (error, stdout, stderr) {     console.log(&#39;stdout: &#39; + stdout);     console.log(&#39;stderr: &#39; + stderr);     if (error !== null) {       console.log(&#39;exec error: &#39; + error);     } }); The callback gets the arguments (error, stdout, stderr). On success, error will be null.  On error, error will be an instance of Error and err.code will be the exit code of the child process, and err.signal will be set to the signal that terminated the process.   There is a second optional argument to specify several options. The default options are   { encoding: &#39;utf8&#39;,   timeout: 0,   maxBuffer: 200*1024,   killSignal: &#39;SIGTERM&#39;,   cwd: null,   env: null } If timeout is greater than 0, then it will kill the child process if it runs longer than timeout milliseconds. The child process is killed with killSignal (default: &#39;SIGTERM&#39;). maxBuffer specifies the largest amount of data allowed on stdout or stderr - if this value is exceeded then the child process is killed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process_execfile_file_args_options_callback","title":"child_process.execFile(file, args, options, callback)","description":"This is similar to child_process.exec() except it does not execute a subshell but rather the specified file directly. This makes it slightly leaner than child_process.exec. It has the same options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process_fork_modulepath_args_options","title":"child\\_process.fork(modulePath, [args], [options])","description":"This is a special case of the spawn() functionality for spawning Node processes. In addition to having all the methods in a normal ChildProcess instance, the returned object has a communication channel built-in. See child.send(message, [sendHandle]) for details.   By default the spawned Node process will have the stdout, stderr associated with the parent&#39;s. To change this behavior set the silent property in the options object to true.   The child process does not automatically exit once it&#39;s done, you need to call process.exit() explicitly. This limitation may be lifted in the future.   These child Nodes are still whole new instances of V8. Assume at least 30ms startup and 10mb memory for each new Node. That is, you cannot create many thousands of them.   The execPath property in the options object allows for a process to be created for the child rather than the current node executable. This should be done with care and by default will talk over the fd represented an environmental variable NODE_CHANNEL_FD on the child process. The input and output on this fd is expected to be line delimited JSON objects."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert","title":"Assert","description":"This module is used for writing unit tests for your applications, you can access it with require(&#39;assert&#39;)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_fail_actual_expected_message_operator","title":"assert.fail(actual, expected, message, operator)","description":"Throws an exception that displays the values for actual and expected separated by the provided operator."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_value_message_assert_ok_value_message","title":"assert(value, message), assert.ok(value, [message])","description":"Tests if value is truthy, it is equivalent to assert.equal(true, !!value, message);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_equal_actual_expected_message","title":"assert.equal(actual, expected, [message])","description":"Tests shallow, coercive equality with the equal comparison operator ( == )."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_notequal_actual_expected_message","title":"assert.notEqual(actual, expected, [message])","description":"Tests shallow, coercive non-equality with the not equal comparison operator ( != )."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_deepequal_actual_expected_message","title":"assert.deepEqual(actual, expected, [message])","description":"Tests for deep equality."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_notdeepequal_actual_expected_message","title":"assert.notDeepEqual(actual, expected, [message])","description":"Tests for any deep inequality."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_strictequal_actual_expected_message","title":"assert.strictEqual(actual, expected, [message])","description":"Tests strict equality, as determined by the strict equality operator ( === )"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_notstrictequal_actual_expected_message","title":"assert.notStrictEqual(actual, expected, [message])","description":"Tests strict non-equality, as determined by the strict not equal operator ( !== )"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_throws_block_error_message","title":"assert.throws(block, [error], [message])","description":"Expects block to throw an error. error can be constructor, regexp or  validation function.   Validate instanceof using constructor:   assert.throws(   function() {     throw new Error(\"Wrong value\");   },   Error ); Validate error message using RegExp:   assert.throws(   function() {     throw new Error(\"Wrong value\");   },   \/value\/ ); Custom error validation:   assert.throws(   function() {     throw new Error(\"Wrong value\");   },   function(err) {     if ( (err instanceof Error) && \/value\/.test(err) ) {       return true;     }   },   \"unexpected error\" );"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_doesnotthrow_block_message","title":"assert.doesNotThrow(block, [message])","description":"Expects block not to throw an error, see assert.throws for details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_iferror_value","title":"assert.ifError(value)","description":"Tests if value is not a false value, throws if it is a true value. Useful when testing the first argument, error in callbacks."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tty","title":"TTY","description":"The tty module houses the tty.ReadStream and tty.WriteStream classes. In most cases, you will not need to use this module directly.   When node detects that it is being run inside a TTY context, then process.stdin will be a tty.ReadStream instance and process.stdout will be a tty.WriteStream instance. The preferred way to check if node is being run in a TTY context is to check process.stdout.isTTY:   $ node -p -e \"Boolean(process.stdout.isTTY)\" true $ node -p -e \"Boolean(process.stdout.isTTY)\" | cat false"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tty_isatty_fd","title":"tty.isatty(fd)","description":"Returns true or false depending on if the fd is associated with a terminal."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tty_setrawmode_mode","title":"tty.setRawMode(mode)","description":"Deprecated. Use tty.ReadStream#setRawMode() (i.e. process.stdin.setRawMode()) instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_class_writestream","title":"Class WriteStream","description":"A net.Socket subclass that represents the writable portion of a tty. In normal circumstances, process.stdout will be the only tty.WriteStream instance ever created (and only when isatty(1) is true)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib","title":"Zlib","description":"You can access this module with:   var zlib = require(&#39;zlib&#39;); This provides bindings to Gzip\/Gunzip, Deflate\/Inflate, and DeflateRaw\/InflateRaw classes.  Each class takes the same options, and is a readable\/writable Stream.   Examples Compressing or decompressing a file can be done by piping an fs.ReadStream into a zlib stream, then into an fs.WriteStream.   var gzip = zlib.createGzip(); var fs = require(&#39;fs&#39;); var inp = fs.createReadStream(&#39;input.txt&#39;); var out = fs.createWriteStream(&#39;input.txt.gz&#39;);  inp.pipe(gzip).pipe(out); Compressing or decompressing data in one step can be done by using the convenience methods.   var input = &#39;.................................&#39;; zlib.deflate(input, function(err, buffer) {   if (!err) {     console.log(buffer.toString(&#39;base64&#39;));   } });  var buffer = new Buffer(&#39;eJzT0yMAAGTvBe8=&#39;, &#39;base64&#39;); zlib.unzip(buffer, function(err, buffer) {   if (!err) {     console.log(buffer.toString());   } }); To use this module in an HTTP client or server, use the accept-encoding on requests, and the content-encoding header on responses.   Note: these examples are drastically simplified to show the basic concept.  Zlib encoding can be expensive, and the results ought to be cached.  See Memory Usage Tuning below for more information on the speed\/memory\/compression tradeoffs involved in zlib usage.   \/\/ client request example var zlib = require(&#39;zlib&#39;); var http = require(&#39;http&#39;); var fs = require(&#39;fs&#39;); var request = http.get({ host: &#39;izs.me&#39;,                          path: &#39;\/&#39;,                          port: 80,                          headers: { &#39;accept-encoding&#39;: &#39;gzip,deflate&#39; } }); request.on(&#39;response&#39;, function(response) {   var output = fs.createWriteStream(&#39;izs.me_index.html&#39;);    switch (response.headers[&#39;content-encoding&#39;]) {     \/\/ or, just use zlib.createUnzip() to handle both cases     case &#39;gzip&#39;:       response.pipe(zlib.createGunzip()).pipe(output);       break;     case &#39;deflate&#39;:       response.pipe(zlib.createInflate()).pipe(output);       break;     default:       response.pipe(output);       break;   } });  \/\/ server example \/\/ Running a gzip operation on every request is quite expensive. \/\/ It would be much more efficient to cache the compressed buffer. var zlib = require(&#39;zlib&#39;); var http = require(&#39;http&#39;); var fs = require(&#39;fs&#39;); http.createServer(function(request, response) {   var raw = fs.createReadStream(&#39;index.html&#39;);   var acceptEncoding = request.headers[&#39;accept-encoding&#39;];   if (!acceptEncoding) {     acceptEncoding = &#39;&#39;;   }    \/\/ Note: this is not a conformant accept-encoding parser.   \/\/ See http:\/\/www.w3.org\/Protocols\/rfc2616\/rfc2616-sec14.html#sec14.3   if (acceptEncoding.match(\/\\bdeflate\\b\/)) {     response.writeHead(200, { &#39;content-encoding&#39;: &#39;deflate&#39; });     raw.pipe(zlib.createDeflate()).pipe(response);   } else if (acceptEncoding.match(\/\\bgzip\\b\/)) {     response.writeHead(200, { &#39;content-encoding&#39;: &#39;gzip&#39; });     raw.pipe(zlib.createGzip()).pipe(response);   } else {     response.writeHead(200, {});     raw.pipe(response);   } }).listen(1337);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_creategzip_options","title":"zlib.createGzip([options])","description":"Returns a new Gzip object with an options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_creategunzip_options","title":"zlib.createGunzip([options])","description":"Returns a new Gunzip object with an options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_createdeflate_options","title":"zlib.createDeflate([options])","description":"Returns a new Deflate object with an options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_createinflate_options","title":"zlib.createInflate([options])","description":"Returns a new Inflate object with an options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_createdeflateraw_options","title":"zlib.createDeflateRaw([options])","description":"Returns a new DeflateRaw object with an options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_createinflateraw_options","title":"zlib.createInflateRaw([options])","description":"Returns a new InflateRaw object with an options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_createunzip_options","title":"zlib.createUnzip([options])","description":"Returns a new Unzip object with an options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_deflate_buf_callback","title":"zlib.deflate(buf, callback)","description":"Compress a string with Deflate."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_deflateraw_buf_callback","title":"zlib.deflateRaw(buf, callback)","description":"Compress a string with DeflateRaw."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_gzip_buf_callback","title":"zlib.gzip(buf, callback)","description":"Compress a string with Gzip."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_gunzip_buf_callback","title":"zlib.gunzip(buf, callback)","description":"Decompress a raw Buffer with Gunzip."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_inflate_buf_callback","title":"zlib.inflate(buf, callback)","description":"Decompress a raw Buffer with Inflate."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_inflateraw_buf_callback","title":"zlib.inflateRaw(buf, callback)","description":"Decompress a raw Buffer with InflateRaw."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_unzip_buf_callback","title":"zlib.unzip(buf, callback)","description":"Decompress a raw Buffer with Unzip."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_convenience_methods","title":"Convenience Methods","description":"All of these take a string or buffer as the first argument, and call the supplied callback with callback(error, result).  The compression\/decompression engine is created using the default settings in all convenience methods.  To supply different options, use the zlib classes directly."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_options","title":"Options","description":"Each class takes an options object.  All options are optional.  (The convenience methods use the default settings for all options.)   Note that some options are only relevant when compressing, and are ignored by the decompression classes.    flush (default: zlib.Z_NO_FLUSH) chunkSize (default: 16*1024) windowBits level (compression only) memLevel (compression only) strategy (compression only) dictionary (deflate\/inflate only, empty dictionary by default)  See the description of deflateInit2 and inflateInit2 at  http:\/\/zlib.net\/manual.html#Advanced for more information on these."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_memory_usage_tuning","title":"Memory Usage Tuning","description":"From zlib\/zconf.h, modified to node&#39;s usage:   The memory requirements for deflate are (in bytes):   (1 << (windowBits+2)) +  (1 << (memLevel+9)) that is: 128K for windowBits=15  +  128K for memLevel = 8 (default values) plus a few kilobytes for small objects.   For example, if you want to reduce the default memory requirements from 256K to 128K, set the options to:   { windowBits: 14, memLevel: 7 } Of course this will generally degrade compression (there&#39;s no free lunch).   The memory requirements for inflate are (in bytes)   1 << windowBits that is, 32K for windowBits=15 (default value) plus a few kilobytes for small objects.   This is in addition to a single internal output slab buffer of size chunkSize, which defaults to 16K.   The speed of zlib compression is affected most dramatically by the level setting.  A higher level will result in better compression, but will take longer to complete.  A lower level will result in less compression, but will be much faster.   In general, greater memory usage options will mean that node has to make fewer calls to zlib, since it&#39;ll be able to process more data in a single write operation.  So, this is another factor that affects the speed, at the cost of memory usage."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_constants","title":"Constants","description":"All of the constants defined in zlib.h are also defined on require(&#39;zlib&#39;). In the normal course of operations, you will not need to ever set any of these.  They are documented here so that their presence is not surprising.  This section is taken almost directly from the zlib documentation.  See  http:\/\/zlib.net\/manual.html#Constants for more details.   Allowed flush values.    zlib.Z_NO_FLUSH zlib.Z_PARTIAL_FLUSH zlib.Z_SYNC_FLUSH zlib.Z_FULL_FLUSH zlib.Z_FINISH zlib.Z_BLOCK zlib.Z_TREES  Return codes for the compression\/decompression functions. Negative values are errors, positive values are used for special but normal events.    zlib.Z_OK zlib.Z_STREAM_END zlib.Z_NEED_DICT zlib.Z_ERRNO zlib.Z_STREAM_ERROR zlib.Z_DATA_ERROR zlib.Z_MEM_ERROR zlib.Z_BUF_ERROR zlib.Z_VERSION_ERROR  Compression levels.    zlib.Z_NO_COMPRESSION zlib.Z_BEST_SPEED zlib.Z_BEST_COMPRESSION zlib.Z_DEFAULT_COMPRESSION  Compression strategy.    zlib.Z_FILTERED zlib.Z_HUFFMAN_ONLY zlib.Z_RLE zlib.Z_FIXED zlib.Z_DEFAULT_STRATEGY  Possible values of the data_type field.    zlib.Z_BINARY zlib.Z_TEXT zlib.Z_ASCII zlib.Z_UNKNOWN  The deflate compression method (the only one supported in this version).    zlib.Z_DEFLATED  For initializing zalloc, zfree, opaque.    zlib.Z_NULL"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os","title":"os","description":"Provides a few basic operating-system related utility functions.   Use require(&#39;os&#39;) to access this module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_tmpdir","title":"os.tmpdir()","description":"Returns the operating system&#39;s default directory for temp files."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_endianness","title":"os.endianness()","description":"Returns the endianness of the CPU. Possible values are \"BE\" or \"LE\"."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_hostname","title":"os.hostname()","description":"Returns the hostname of the operating system."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_type","title":"os.type()","description":"Returns the operating system name."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_platform","title":"os.platform()","description":"Returns the operating system platform."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_arch","title":"os.arch()","description":"Returns the operating system CPU architecture."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_release","title":"os.release()","description":"Returns the operating system release."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_uptime","title":"os.uptime()","description":"Returns the system uptime in seconds."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_loadavg","title":"os.loadavg()","description":"Returns an array containing the 1, 5, and 15 minute load averages."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_totalmem","title":"os.totalmem()","description":"Returns the total amount of system memory in bytes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_freemem","title":"os.freemem()","description":"Returns the amount of free system memory in bytes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_cpus","title":"os.cpus()","description":"Returns an array of objects containing information about each CPU\/core installed: model, speed (in MHz), and times (an object containing the number of milliseconds the CPU\/core spent in: user, nice, sys, idle, and irq).   Example inspection of os.cpus:   [ { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,     speed: 2926,     times:      { user: 252020,        nice: 0,        sys: 30340,        idle: 1070356870,        irq: 0 } },   { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,     speed: 2926,     times:      { user: 306960,        nice: 0,        sys: 26980,        idle: 1071569080,        irq: 0 } },   { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,     speed: 2926,     times:      { user: 248450,        nice: 0,        sys: 21750,        idle: 1070919370,        irq: 0 } },   { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,     speed: 2926,     times:      { user: 256880,        nice: 0,        sys: 19430,        idle: 1070905480,        irq: 20 } },   { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,     speed: 2926,     times:      { user: 511580,        nice: 20,        sys: 40900,        idle: 1070842510,        irq: 0 } },   { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,     speed: 2926,     times:      { user: 291660,        nice: 0,        sys: 34360,        idle: 1070888000,        irq: 10 } },   { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,     speed: 2926,     times:      { user: 308260,        nice: 0,        sys: 55410,        idle: 1071129970,        irq: 880 } },   { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,     speed: 2926,     times:      { user: 266450,        nice: 1480,        sys: 34920,        idle: 1072572010,        irq: 30 } } ]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_networkinterfaces","title":"os.networkInterfaces()","description":"Get a list of network interfaces:   { lo0:     [ { address: &#39;::1&#39;, family: &#39;IPv6&#39;, internal: true },      { address: &#39;fe80::1&#39;, family: &#39;IPv6&#39;, internal: true },      { address: &#39;127.0.0.1&#39;, family: &#39;IPv4&#39;, internal: true } ],   en1:     [ { address: &#39;fe80::cabc:c8ff:feef:f996&#39;, family: &#39;IPv6&#39;,        internal: false },      { address: &#39;10.0.1.123&#39;, family: &#39;IPv4&#39;, internal: false } ],   vmnet1: [ { address: &#39;10.99.99.254&#39;, family: &#39;IPv4&#39;, internal: false } ],   vmnet8: [ { address: &#39;10.88.88.1&#39;, family: &#39;IPv4&#39;, internal: false } ],   ppp0: [ { address: &#39;10.2.0.231&#39;, family: &#39;IPv4&#39;, internal: false } ] }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cluster","title":"Cluster","description":"A single instance of Node runs in a single thread. To take advantage of multi-core systems the user will sometimes want to launch a cluster of Node processes to handle the load.   The cluster module allows you to easily create a network of processes that all share server ports.   var cluster = require(&#39;cluster&#39;); var http = require(&#39;http&#39;); var numCPUs = require(&#39;os&#39;).cpus().length;  if (cluster.isMaster) {   \/\/ Fork workers.   for (var i = 0; i < numCPUs; i++) {     cluster.fork();   }    cluster.on(&#39;exit&#39;, function(worker, code, signal) {     console.log(&#39;worker &#39; + worker.process.pid + &#39; died&#39;);   }); } else {   \/\/ Workers can share any TCP connection   \/\/ In this case its a HTTP server   http.createServer(function(req, res) {     res.writeHead(200);     res.end(\"hello world\\n\");   }).listen(8000); } Running node will now share port 8000 between the workers:   % NODE_DEBUG=cluster node server.js 23521,Master Worker 23524 online 23521,Master Worker 23526 online 23521,Master Worker 23523 online 23521,Master Worker 23528 online This feature was introduced recently, and may change in future versions. Please try it out and provide feedback.   Also note that, on Windows, it is not yet possible to set up a named pipe server in a worker."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cluster_setupmaster_settings","title":"cluster.setupMaster([settings])","description":"setupMaster is used to change the default &#39;fork&#39; behavior. The new settings are effective immediately and permanently, they cannot be changed later on.   Example:   var cluster = require(\"cluster\"); cluster.setupMaster({   exec : \"worker.js\",   args : [\"--use\", \"https\"],   silent : true }); cluster.fork();"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cluster_fork_env","title":"cluster.fork([env])","description":"Spawn a new worker process. This can only be called from the master process."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cluster_disconnect_callback","title":"cluster.disconnect([callback])","description":"When calling this method, all workers will commit a graceful suicide. When they are disconnected all internal handlers will be closed, allowing the master process to die graceful if no other event is waiting.   The method takes an optional callback argument which will be called when finished."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_how_it_works","title":"How It Works","description":"The worker processes are spawned using the child_process.fork method, so that they can communicate with the parent via IPC and pass server handles back and forth.   When you call server.listen(...) in a worker, it serializes the arguments and passes the request to the master process.  If the master process already has a listening server matching the worker&#39;s requirements, then it passes the handle to the worker.  If it does not already have a listening server matching that requirement, then it will create one, and pass the handle to the child.   This causes potentially surprising behavior in three edge cases:    server.listen({fd: 7}) Because the message is passed to the master, file descriptor 7 in the parent will be listened on, and the handle passed to the worker, rather than listening to the worker&#39;s idea of what the number 7 file descriptor references. server.listen(handle) Listening on handles explicitly will cause the worker to use the supplied handle, rather than talk to the master process.  If the worker already has the handle, then it&#39;s presumed that you know what you are doing. server.listen(0) Normally, this will cause servers to listen on a random port.  However, in a cluster, each worker will receive the same \"random\" port each time they do listen(0).  In essence, the port is random the first time, but predictable thereafter.  If you want to listen on a unique port, generate a port number based on the cluster worker ID.  When multiple processes are all accept()ing on the same underlying resource, the operating system load-balances across them very efficiently.  There is no routing logic in Node.js, or in your program, and no shared state between the workers.  Therefore, it is important to design your program such that it does not rely too heavily on in-memory data objects for things like sessions and login.   Because workers are all separate processes, they can be killed or re-spawned depending on your program&#39;s needs, without affecting other workers.  As long as there are some workers still alive, the server will continue to accept connections.  Node does not automatically manage the number of workers for you, however.  It is your responsibility to manage the worker pool for your application&#39;s needs."}]